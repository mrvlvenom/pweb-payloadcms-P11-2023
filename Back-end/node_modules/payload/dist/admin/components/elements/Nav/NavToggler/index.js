"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "NavToggler", {
    enumerable: true,
    get: function() {
        return NavToggler;
    }
});
const _windowinfo = require("@faceless-ui/window-info");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _reacti18next = require("react-i18next");
const _Preferences = require("../../../utilities/Preferences");
const _context = require("../context");
require("./index.scss");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const baseClass = 'nav-toggler';
const NavToggler = (props)=>{
    const { id, children, className, tabIndex = 0 } = props;
    const { t } = (0, _reacti18next.useTranslation)('general');
    const { setPreference } = (0, _Preferences.usePreferences)();
    const { navOpen, setNavOpen } = (0, _context.useNav)();
    const { breakpoints: { l: largeBreak } } = (0, _windowinfo.useWindowInfo)();
    return /*#__PURE__*/ _react.default.createElement("button", {
        "aria-label": t('menu'),
        className: [
            baseClass,
            navOpen && `${baseClass}--is-open`,
            className
        ].filter(Boolean).join(' '),
        id: id,
        onClick: async ()=>{
            setNavOpen(!navOpen);
            // only when the user explicitly toggles the nav on desktop do we want to set the preference
            // this is because the js may open or close the nav based on the window size, routing, etc
            if (!largeBreak) {
                await setPreference('nav', {
                    open: !navOpen
                });
            }
        },
        tabIndex: tabIndex,
        type: "button"
    }, children);
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2VsZW1lbnRzL05hdi9OYXZUb2dnbGVyL2luZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VXaW5kb3dJbmZvIH0gZnJvbSAnQGZhY2VsZXNzLXVpL3dpbmRvdy1pbmZvJ1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgdXNlVHJhbnNsYXRpb24gfSBmcm9tICdyZWFjdC1pMThuZXh0J1xuXG5pbXBvcnQgeyB1c2VQcmVmZXJlbmNlcyB9IGZyb20gJy4uLy4uLy4uL3V0aWxpdGllcy9QcmVmZXJlbmNlcydcbmltcG9ydCB7IHVzZU5hdiB9IGZyb20gJy4uL2NvbnRleHQnXG5pbXBvcnQgJy4vaW5kZXguc2NzcydcblxuY29uc3QgYmFzZUNsYXNzID0gJ25hdi10b2dnbGVyJ1xuXG5leHBvcnQgY29uc3QgTmF2VG9nZ2xlcjogUmVhY3QuRkM8e1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZVxuICBjbGFzc05hbWU/OiBzdHJpbmdcbiAgaWQ/OiBzdHJpbmdcbiAgdGFiSW5kZXg/OiBudW1iZXJcbn0+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgaWQsIGNoaWxkcmVuLCBjbGFzc05hbWUsIHRhYkluZGV4ID0gMCB9ID0gcHJvcHNcblxuICBjb25zdCB7IHQgfSA9IHVzZVRyYW5zbGF0aW9uKCdnZW5lcmFsJylcblxuICBjb25zdCB7IHNldFByZWZlcmVuY2UgfSA9IHVzZVByZWZlcmVuY2VzKClcblxuICBjb25zdCB7IG5hdk9wZW4sIHNldE5hdk9wZW4gfSA9IHVzZU5hdigpXG5cbiAgY29uc3Qge1xuICAgIGJyZWFrcG9pbnRzOiB7IGw6IGxhcmdlQnJlYWsgfSxcbiAgfSA9IHVzZVdpbmRvd0luZm8oKVxuXG4gIHJldHVybiAoXG4gICAgPGJ1dHRvblxuICAgICAgYXJpYS1sYWJlbD17dCgnbWVudScpfVxuICAgICAgY2xhc3NOYW1lPXtbYmFzZUNsYXNzLCBuYXZPcGVuICYmIGAke2Jhc2VDbGFzc30tLWlzLW9wZW5gLCBjbGFzc05hbWVdXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oJyAnKX1cbiAgICAgIGlkPXtpZH1cbiAgICAgIG9uQ2xpY2s9e2FzeW5jICgpID0+IHtcbiAgICAgICAgc2V0TmF2T3BlbighbmF2T3BlbilcblxuICAgICAgICAvLyBvbmx5IHdoZW4gdGhlIHVzZXIgZXhwbGljaXRseSB0b2dnbGVzIHRoZSBuYXYgb24gZGVza3RvcCBkbyB3ZSB3YW50IHRvIHNldCB0aGUgcHJlZmVyZW5jZVxuICAgICAgICAvLyB0aGlzIGlzIGJlY2F1c2UgdGhlIGpzIG1heSBvcGVuIG9yIGNsb3NlIHRoZSBuYXYgYmFzZWQgb24gdGhlIHdpbmRvdyBzaXplLCByb3V0aW5nLCBldGNcbiAgICAgICAgaWYgKCFsYXJnZUJyZWFrKSB7XG4gICAgICAgICAgYXdhaXQgc2V0UHJlZmVyZW5jZSgnbmF2Jywge1xuICAgICAgICAgICAgb3BlbjogIW5hdk9wZW4sXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfX1cbiAgICAgIHRhYkluZGV4PXt0YWJJbmRleH1cbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIk5hdlRvZ2dsZXIiLCJiYXNlQ2xhc3MiLCJwcm9wcyIsImlkIiwiY2hpbGRyZW4iLCJjbGFzc05hbWUiLCJ0YWJJbmRleCIsInQiLCJ1c2VUcmFuc2xhdGlvbiIsInNldFByZWZlcmVuY2UiLCJ1c2VQcmVmZXJlbmNlcyIsIm5hdk9wZW4iLCJzZXROYXZPcGVuIiwidXNlTmF2IiwiYnJlYWtwb2ludHMiLCJsIiwibGFyZ2VCcmVhayIsInVzZVdpbmRvd0luZm8iLCJidXR0b24iLCJhcmlhLWxhYmVsIiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJvbkNsaWNrIiwib3BlbiIsInR5cGUiXSwibWFwcGluZ3MiOiI7Ozs7K0JBVWFBOzs7ZUFBQUE7Ozs0QkFWaUI7OERBQ1o7OEJBQ2E7NkJBRUE7eUJBQ1I7UUFDaEI7Ozs7OztBQUVQLE1BQU1DLFlBQVk7QUFFWCxNQUFNRCxhQUtSLENBQUNFO0lBQ0osTUFBTSxFQUFFQyxFQUFFLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxXQUFXLENBQUMsRUFBRSxHQUFHSjtJQUVsRCxNQUFNLEVBQUVLLENBQUMsRUFBRSxHQUFHQyxJQUFBQSw0QkFBYyxFQUFDO0lBRTdCLE1BQU0sRUFBRUMsYUFBYSxFQUFFLEdBQUdDLElBQUFBLDJCQUFjO0lBRXhDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxVQUFVLEVBQUUsR0FBR0MsSUFBQUEsZUFBTTtJQUV0QyxNQUFNLEVBQ0pDLGFBQWEsRUFBRUMsR0FBR0MsVUFBVSxFQUFFLEVBQy9CLEdBQUdDLElBQUFBLHlCQUFhO0lBRWpCLHFCQUNFLDZCQUFDQztRQUNDQyxjQUFZWixFQUFFO1FBQ2RGLFdBQVc7WUFBQ0o7WUFBV1UsV0FBVyxDQUFDLEVBQUVWLFVBQVUsU0FBUyxDQUFDO1lBQUVJO1NBQVUsQ0FDbEVlLE1BQU0sQ0FBQ0MsU0FDUEMsSUFBSSxDQUFDO1FBQ1JuQixJQUFJQTtRQUNKb0IsU0FBUztZQUNQWCxXQUFXLENBQUNEO1lBRVosNEZBQTRGO1lBQzVGLDBGQUEwRjtZQUMxRixJQUFJLENBQUNLLFlBQVk7Z0JBQ2YsTUFBTVAsY0FBYyxPQUFPO29CQUN6QmUsTUFBTSxDQUFDYjtnQkFDVDtZQUNGO1FBQ0Y7UUFDQUwsVUFBVUE7UUFDVm1CLE1BQUs7T0FFSnJCO0FBR1AifQ==