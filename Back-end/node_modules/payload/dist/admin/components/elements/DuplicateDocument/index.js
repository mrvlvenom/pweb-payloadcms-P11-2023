"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _modal = require("@faceless-ui/modal");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _reactrouterdom = require("react-router-dom");
const _reacttoastify = require("react-toastify");
const _getTranslation = require("../../../../utilities/getTranslation");
const _api = require("../../../api");
const _context = require("../../forms/Form/context");
const _Minimal = /*#__PURE__*/ _interop_require_default(require("../../templates/Minimal"));
const _Config = require("../../utilities/Config");
const _Button = /*#__PURE__*/ _interop_require_default(require("../Button"));
const _PopupButtonList = /*#__PURE__*/ _interop_require_wildcard(require("../Popup/PopupButtonList"));
require("./index.scss");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const baseClass = 'duplicate';
const Duplicate = ({ id, collection, slug })=>{
    const { push } = (0, _reactrouterdom.useHistory)();
    const modified = (0, _context.useFormModified)();
    const { toggleModal } = (0, _modal.useModal)();
    const { setModified } = (0, _context.useForm)();
    const { localization, routes: { api }, serverURL } = (0, _Config.useConfig)();
    const { routes: { admin } } = (0, _Config.useConfig)();
    const [hasClicked, setHasClicked] = (0, _react.useState)(false);
    const { i18n, t } = (0, _reacti18next.useTranslation)('general');
    const modalSlug = `duplicate-${id}`;
    const handleClick = (0, _react.useCallback)(async (override = false)=>{
        setHasClicked(true);
        if (modified && !override) {
            toggleModal(modalSlug);
            return;
        }
        const saveDocument = async ({ id, duplicateID = '', locale = '' })=>{
            const response = await _api.requests.get(`${serverURL}${api}/${slug}/${id}`, {
                headers: {
                    'Accept-Language': i18n.language
                },
                params: {
                    depth: 0,
                    draft: true,
                    'fallback-locale': 'none',
                    locale
                }
            });
            let data = await response.json();
            if (typeof collection.admin.hooks?.beforeDuplicate === 'function') {
                data = await collection.admin.hooks.beforeDuplicate({
                    collection,
                    data,
                    locale
                });
            }
            if (!duplicateID) {
                if ('createdAt' in data) delete data.createdAt;
                if ('updatedAt' in data) delete data.updatedAt;
            }
            const result = await _api.requests[duplicateID ? 'patch' : 'post'](`${serverURL}${api}/${slug}/${duplicateID}?locale=${locale}&fallback-locale=none`, {
                body: JSON.stringify(data),
                headers: {
                    'Accept-Language': i18n.language,
                    'Content-Type': 'application/json'
                }
            });
            const json = await result.json();
            if (result.status === 201 || result.status === 200) {
                return json.doc.id;
            }
            json.errors.forEach((error)=>_reacttoastify.toast.error(error.message));
            return null;
        };
        let duplicateID;
        let abort = false;
        if (localization) {
            await localization.localeCodes.reduce(async (priorLocalePatch, locale)=>{
                await priorLocalePatch;
                if (abort) return;
                duplicateID = await saveDocument({
                    id,
                    duplicateID,
                    locale
                });
                if (!duplicateID) {
                    abort = true;
                }
            }, Promise.resolve());
            if (abort && duplicateID) {
                // delete the duplicate doc to prevent incomplete
                await _api.requests.delete(`${serverURL}${api}/${slug}/${duplicateID}`, {
                    headers: {
                        'Accept-Language': i18n.language
                    }
                });
            }
        } else {
            duplicateID = await saveDocument({
                id
            });
        }
        if (!duplicateID) {
            return;
        }
        _reacttoastify.toast.success(t('successfullyDuplicated', {
            label: (0, _getTranslation.getTranslation)(collection.labels.singular, i18n)
        }), {
            autoClose: 3000
        });
        setModified(false);
        setTimeout(()=>{
            push({
                pathname: `${admin}/collections/${slug}/${duplicateID}`
            });
        }, 10);
    }, [
        modified,
        localization,
        t,
        i18n,
        collection,
        setModified,
        toggleModal,
        modalSlug,
        serverURL,
        api,
        slug,
        id,
        push,
        admin
    ]);
    const confirm = (0, _react.useCallback)(async ()=>{
        setHasClicked(false);
        await handleClick(true);
    }, [
        handleClick
    ]);
    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(_PopupButtonList.Button, {
        id: "action-duplicate",
        onClick: ()=>handleClick(false)
    }, t('duplicate')), modified && hasClicked && /*#__PURE__*/ _react.default.createElement(_modal.Modal, {
        className: `${baseClass}__modal`,
        slug: modalSlug
    }, /*#__PURE__*/ _react.default.createElement(_Minimal.default, {
        className: `${baseClass}__modal-template`
    }, /*#__PURE__*/ _react.default.createElement("h1", null, t('confirmDuplication')), /*#__PURE__*/ _react.default.createElement("p", null, t('unsavedChangesDuplicate')), /*#__PURE__*/ _react.default.createElement(_Button.default, {
        buttonStyle: "secondary",
        id: "confirm-cancel",
        onClick: ()=>toggleModal(modalSlug),
        type: "button"
    }, t('cancel')), /*#__PURE__*/ _react.default.createElement(_Button.default, {
        id: "confirm-duplicate",
        onClick: confirm
    }, t('duplicateWithoutSaving')))));
};
const _default = Duplicate;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2VsZW1lbnRzL0R1cGxpY2F0ZURvY3VtZW50L2luZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNb2RhbCwgdXNlTW9kYWwgfSBmcm9tICdAZmFjZWxlc3MtdWkvbW9kYWwnXG5pbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VUcmFuc2xhdGlvbiB9IGZyb20gJ3JlYWN0LWkxOG5leHQnXG5pbXBvcnQgeyB1c2VIaXN0b3J5IH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSdcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSAncmVhY3QtdG9hc3RpZnknXG5cbmltcG9ydCB0eXBlIHsgUHJvcHMgfSBmcm9tICcuL3R5cGVzJ1xuXG5pbXBvcnQgeyBnZXRUcmFuc2xhdGlvbiB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxpdGllcy9nZXRUcmFuc2xhdGlvbidcbmltcG9ydCB7IHJlcXVlc3RzIH0gZnJvbSAnLi4vLi4vLi4vYXBpJ1xuaW1wb3J0IHsgdXNlRm9ybSwgdXNlRm9ybU1vZGlmaWVkIH0gZnJvbSAnLi4vLi4vZm9ybXMvRm9ybS9jb250ZXh0J1xuaW1wb3J0IE1pbmltYWxUZW1wbGF0ZSBmcm9tICcuLi8uLi90ZW1wbGF0ZXMvTWluaW1hbCdcbmltcG9ydCB7IHVzZUNvbmZpZyB9IGZyb20gJy4uLy4uL3V0aWxpdGllcy9Db25maWcnXG5pbXBvcnQgQnV0dG9uIGZyb20gJy4uL0J1dHRvbidcbmltcG9ydCAqIGFzIFBvcHVwTGlzdCBmcm9tICcuLi9Qb3B1cC9Qb3B1cEJ1dHRvbkxpc3QnXG5pbXBvcnQgJy4vaW5kZXguc2NzcydcblxuY29uc3QgYmFzZUNsYXNzID0gJ2R1cGxpY2F0ZSdcblxuY29uc3QgRHVwbGljYXRlOiBSZWFjdC5GQzxQcm9wcz4gPSAoeyBpZCwgY29sbGVjdGlvbiwgc2x1ZyB9KSA9PiB7XG4gIGNvbnN0IHsgcHVzaCB9ID0gdXNlSGlzdG9yeSgpXG4gIGNvbnN0IG1vZGlmaWVkID0gdXNlRm9ybU1vZGlmaWVkKClcbiAgY29uc3QgeyB0b2dnbGVNb2RhbCB9ID0gdXNlTW9kYWwoKVxuICBjb25zdCB7IHNldE1vZGlmaWVkIH0gPSB1c2VGb3JtKClcbiAgY29uc3Qge1xuICAgIGxvY2FsaXphdGlvbixcbiAgICByb3V0ZXM6IHsgYXBpIH0sXG4gICAgc2VydmVyVVJMLFxuICB9ID0gdXNlQ29uZmlnKClcbiAgY29uc3Qge1xuICAgIHJvdXRlczogeyBhZG1pbiB9LFxuICB9ID0gdXNlQ29uZmlnKClcbiAgY29uc3QgW2hhc0NsaWNrZWQsIHNldEhhc0NsaWNrZWRdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpXG4gIGNvbnN0IHsgaTE4biwgdCB9ID0gdXNlVHJhbnNsYXRpb24oJ2dlbmVyYWwnKVxuXG4gIGNvbnN0IG1vZGFsU2x1ZyA9IGBkdXBsaWNhdGUtJHtpZH1gXG5cbiAgY29uc3QgaGFuZGxlQ2xpY2sgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAob3ZlcnJpZGUgPSBmYWxzZSkgPT4ge1xuICAgICAgc2V0SGFzQ2xpY2tlZCh0cnVlKVxuXG4gICAgICBpZiAobW9kaWZpZWQgJiYgIW92ZXJyaWRlKSB7XG4gICAgICAgIHRvZ2dsZU1vZGFsKG1vZGFsU2x1ZylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNhdmVEb2N1bWVudCA9IGFzeW5jICh7XG4gICAgICAgIGlkLFxuICAgICAgICBkdXBsaWNhdGVJRCA9ICcnLFxuICAgICAgICBsb2NhbGUgPSAnJyxcbiAgICAgIH0pOiBQcm9taXNlPG51bGwgfCBzdHJpbmc+ID0+IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0cy5nZXQoYCR7c2VydmVyVVJMfSR7YXBpfS8ke3NsdWd9LyR7aWR9YCwge1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiBpMThuLmxhbmd1YWdlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgICAgIGRyYWZ0OiB0cnVlLFxuICAgICAgICAgICAgJ2ZhbGxiYWNrLWxvY2FsZSc6ICdub25lJyxcbiAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICBsZXQgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbi5hZG1pbi5ob29rcz8uYmVmb3JlRHVwbGljYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGF0YSA9IGF3YWl0IGNvbGxlY3Rpb24uYWRtaW4uaG9va3MuYmVmb3JlRHVwbGljYXRlKHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWR1cGxpY2F0ZUlEKSB7XG4gICAgICAgICAgaWYgKCdjcmVhdGVkQXQnIGluIGRhdGEpIGRlbGV0ZSBkYXRhLmNyZWF0ZWRBdFxuICAgICAgICAgIGlmICgndXBkYXRlZEF0JyBpbiBkYXRhKSBkZWxldGUgZGF0YS51cGRhdGVkQXRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3RzW2R1cGxpY2F0ZUlEID8gJ3BhdGNoJyA6ICdwb3N0J10oXG4gICAgICAgICAgYCR7c2VydmVyVVJMfSR7YXBpfS8ke3NsdWd9LyR7ZHVwbGljYXRlSUR9P2xvY2FsZT0ke2xvY2FsZX0mZmFsbGJhY2stbG9jYWxlPW5vbmVgLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnQWNjZXB0LUxhbmd1YWdlJzogaTE4bi5sYW5ndWFnZSxcbiAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzdWx0Lmpzb24oKVxuXG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAyMDEgfHwgcmVzdWx0LnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgcmV0dXJuIGpzb24uZG9jLmlkXG4gICAgICAgIH1cbiAgICAgICAganNvbi5lcnJvcnMuZm9yRWFjaCgoZXJyb3IpID0+IHRvYXN0LmVycm9yKGVycm9yLm1lc3NhZ2UpKVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBsZXQgZHVwbGljYXRlSURcbiAgICAgIGxldCBhYm9ydCA9IGZhbHNlXG5cbiAgICAgIGlmIChsb2NhbGl6YXRpb24pIHtcbiAgICAgICAgYXdhaXQgbG9jYWxpemF0aW9uLmxvY2FsZUNvZGVzLnJlZHVjZShhc3luYyAocHJpb3JMb2NhbGVQYXRjaCwgbG9jYWxlKSA9PiB7XG4gICAgICAgICAgYXdhaXQgcHJpb3JMb2NhbGVQYXRjaFxuICAgICAgICAgIGlmIChhYm9ydCkgcmV0dXJuXG4gICAgICAgICAgZHVwbGljYXRlSUQgPSBhd2FpdCBzYXZlRG9jdW1lbnQoeyBpZCwgZHVwbGljYXRlSUQsIGxvY2FsZSB9KVxuICAgICAgICAgIGlmICghZHVwbGljYXRlSUQpIHtcbiAgICAgICAgICAgIGFib3J0ID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgUHJvbWlzZS5yZXNvbHZlKCkpXG5cbiAgICAgICAgaWYgKGFib3J0ICYmIGR1cGxpY2F0ZUlEKSB7XG4gICAgICAgICAgLy8gZGVsZXRlIHRoZSBkdXBsaWNhdGUgZG9jIHRvIHByZXZlbnQgaW5jb21wbGV0ZVxuICAgICAgICAgIGF3YWl0IHJlcXVlc3RzLmRlbGV0ZShgJHtzZXJ2ZXJVUkx9JHthcGl9LyR7c2x1Z30vJHtkdXBsaWNhdGVJRH1gLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiBpMThuLmxhbmd1YWdlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkdXBsaWNhdGVJRCA9IGF3YWl0IHNhdmVEb2N1bWVudCh7IGlkIH0pXG4gICAgICB9XG5cbiAgICAgIGlmICghZHVwbGljYXRlSUQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRvYXN0LnN1Y2Nlc3MoXG4gICAgICAgIHQoJ3N1Y2Nlc3NmdWxseUR1cGxpY2F0ZWQnLCB7IGxhYmVsOiBnZXRUcmFuc2xhdGlvbihjb2xsZWN0aW9uLmxhYmVscy5zaW5ndWxhciwgaTE4bikgfSksXG4gICAgICAgIHsgYXV0b0Nsb3NlOiAzMDAwIH0sXG4gICAgICApXG5cbiAgICAgIHNldE1vZGlmaWVkKGZhbHNlKVxuXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcHVzaCh7XG4gICAgICAgICAgcGF0aG5hbWU6IGAke2FkbWlufS9jb2xsZWN0aW9ucy8ke3NsdWd9LyR7ZHVwbGljYXRlSUR9YCxcbiAgICAgICAgfSlcbiAgICAgIH0sIDEwKVxuICAgIH0sXG4gICAgW1xuICAgICAgbW9kaWZpZWQsXG4gICAgICBsb2NhbGl6YXRpb24sXG4gICAgICB0LFxuICAgICAgaTE4bixcbiAgICAgIGNvbGxlY3Rpb24sXG4gICAgICBzZXRNb2RpZmllZCxcbiAgICAgIHRvZ2dsZU1vZGFsLFxuICAgICAgbW9kYWxTbHVnLFxuICAgICAgc2VydmVyVVJMLFxuICAgICAgYXBpLFxuICAgICAgc2x1ZyxcbiAgICAgIGlkLFxuICAgICAgcHVzaCxcbiAgICAgIGFkbWluLFxuICAgIF0sXG4gIClcblxuICBjb25zdCBjb25maXJtID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIHNldEhhc0NsaWNrZWQoZmFsc2UpXG4gICAgYXdhaXQgaGFuZGxlQ2xpY2sodHJ1ZSlcbiAgfSwgW2hhbmRsZUNsaWNrXSlcblxuICByZXR1cm4gKFxuICAgIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgIDxQb3B1cExpc3QuQnV0dG9uIGlkPVwiYWN0aW9uLWR1cGxpY2F0ZVwiIG9uQ2xpY2s9eygpID0+IGhhbmRsZUNsaWNrKGZhbHNlKX0+XG4gICAgICAgIHt0KCdkdXBsaWNhdGUnKX1cbiAgICAgIDwvUG9wdXBMaXN0LkJ1dHRvbj5cbiAgICAgIHttb2RpZmllZCAmJiBoYXNDbGlja2VkICYmIChcbiAgICAgICAgPE1vZGFsIGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fbW9kYWxgfSBzbHVnPXttb2RhbFNsdWd9PlxuICAgICAgICAgIDxNaW5pbWFsVGVtcGxhdGUgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19tb2RhbC10ZW1wbGF0ZWB9PlxuICAgICAgICAgICAgPGgxPnt0KCdjb25maXJtRHVwbGljYXRpb24nKX08L2gxPlxuICAgICAgICAgICAgPHA+e3QoJ3Vuc2F2ZWRDaGFuZ2VzRHVwbGljYXRlJyl9PC9wPlxuICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICBidXR0b25TdHlsZT1cInNlY29uZGFyeVwiXG4gICAgICAgICAgICAgIGlkPVwiY29uZmlybS1jYW5jZWxcIlxuICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB0b2dnbGVNb2RhbChtb2RhbFNsdWcpfVxuICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3QoJ2NhbmNlbCcpfVxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8QnV0dG9uIGlkPVwiY29uZmlybS1kdXBsaWNhdGVcIiBvbkNsaWNrPXtjb25maXJtfT5cbiAgICAgICAgICAgICAge3QoJ2R1cGxpY2F0ZVdpdGhvdXRTYXZpbmcnKX1cbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgIDwvTWluaW1hbFRlbXBsYXRlPlxuICAgICAgICA8L01vZGFsPlxuICAgICAgKX1cbiAgICA8L1JlYWN0LkZyYWdtZW50PlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IER1cGxpY2F0ZVxuIl0sIm5hbWVzIjpbImJhc2VDbGFzcyIsIkR1cGxpY2F0ZSIsImlkIiwiY29sbGVjdGlvbiIsInNsdWciLCJwdXNoIiwidXNlSGlzdG9yeSIsIm1vZGlmaWVkIiwidXNlRm9ybU1vZGlmaWVkIiwidG9nZ2xlTW9kYWwiLCJ1c2VNb2RhbCIsInNldE1vZGlmaWVkIiwidXNlRm9ybSIsImxvY2FsaXphdGlvbiIsInJvdXRlcyIsImFwaSIsInNlcnZlclVSTCIsInVzZUNvbmZpZyIsImFkbWluIiwiaGFzQ2xpY2tlZCIsInNldEhhc0NsaWNrZWQiLCJ1c2VTdGF0ZSIsImkxOG4iLCJ0IiwidXNlVHJhbnNsYXRpb24iLCJtb2RhbFNsdWciLCJoYW5kbGVDbGljayIsInVzZUNhbGxiYWNrIiwib3ZlcnJpZGUiLCJzYXZlRG9jdW1lbnQiLCJkdXBsaWNhdGVJRCIsImxvY2FsZSIsInJlc3BvbnNlIiwicmVxdWVzdHMiLCJnZXQiLCJoZWFkZXJzIiwibGFuZ3VhZ2UiLCJwYXJhbXMiLCJkZXB0aCIsImRyYWZ0IiwiZGF0YSIsImpzb24iLCJob29rcyIsImJlZm9yZUR1cGxpY2F0ZSIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsInJlc3VsdCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhdHVzIiwiZG9jIiwiZXJyb3JzIiwiZm9yRWFjaCIsImVycm9yIiwidG9hc3QiLCJtZXNzYWdlIiwiYWJvcnQiLCJsb2NhbGVDb2RlcyIsInJlZHVjZSIsInByaW9yTG9jYWxlUGF0Y2giLCJQcm9taXNlIiwicmVzb2x2ZSIsImRlbGV0ZSIsInN1Y2Nlc3MiLCJsYWJlbCIsImdldFRyYW5zbGF0aW9uIiwibGFiZWxzIiwic2luZ3VsYXIiLCJhdXRvQ2xvc2UiLCJzZXRUaW1lb3V0IiwicGF0aG5hbWUiLCJjb25maXJtIiwiUmVhY3QiLCJGcmFnbWVudCIsIlBvcHVwTGlzdCIsIkJ1dHRvbiIsIm9uQ2xpY2siLCJNb2RhbCIsImNsYXNzTmFtZSIsIk1pbmltYWxUZW1wbGF0ZSIsImgxIiwicCIsImJ1dHRvblN0eWxlIiwidHlwZSJdLCJtYXBwaW5ncyI6Ijs7OzsrQkE2TEE7OztlQUFBOzs7dUJBN0xnQzsrREFDYTs4QkFDZDtnQ0FDSjsrQkFDTDtnQ0FJUztxQkFDTjt5QkFDZ0I7Z0VBQ2I7d0JBQ0Y7K0RBQ1A7eUVBQ1E7UUFDcEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVQLE1BQU1BLFlBQVk7QUFFbEIsTUFBTUMsWUFBNkIsQ0FBQyxFQUFFQyxFQUFFLEVBQUVDLFVBQVUsRUFBRUMsSUFBSSxFQUFFO0lBQzFELE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUdDLElBQUFBLDBCQUFVO0lBQzNCLE1BQU1DLFdBQVdDLElBQUFBLHdCQUFlO0lBQ2hDLE1BQU0sRUFBRUMsV0FBVyxFQUFFLEdBQUdDLElBQUFBLGVBQVE7SUFDaEMsTUFBTSxFQUFFQyxXQUFXLEVBQUUsR0FBR0MsSUFBQUEsZ0JBQU87SUFDL0IsTUFBTSxFQUNKQyxZQUFZLEVBQ1pDLFFBQVEsRUFBRUMsR0FBRyxFQUFFLEVBQ2ZDLFNBQVMsRUFDVixHQUFHQyxJQUFBQSxpQkFBUztJQUNiLE1BQU0sRUFDSkgsUUFBUSxFQUFFSSxLQUFLLEVBQUUsRUFDbEIsR0FBR0QsSUFBQUEsaUJBQVM7SUFDYixNQUFNLENBQUNFLFlBQVlDLGNBQWMsR0FBR0MsSUFBQUEsZUFBUSxFQUFVO0lBQ3RELE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxDQUFDLEVBQUUsR0FBR0MsSUFBQUEsNEJBQWMsRUFBQztJQUVuQyxNQUFNQyxZQUFZLENBQUMsVUFBVSxFQUFFdkIsR0FBRyxDQUFDO0lBRW5DLE1BQU13QixjQUFjQyxJQUFBQSxrQkFBVyxFQUM3QixPQUFPQyxXQUFXLEtB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