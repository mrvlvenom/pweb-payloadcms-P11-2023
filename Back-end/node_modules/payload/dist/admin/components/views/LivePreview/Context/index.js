"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "LivePreviewProvider", {
    enumerable: true,
    get: function() {
        return LivePreviewProvider;
    }
});
const _core = require("@dnd-kit/core");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _fieldSchemaToJSON = require("../../../../../utilities/fieldSchemaToJSON");
const _collisionDetection = require("./collisionDetection");
const _context = require("./context");
const _sizeReducer = require("./sizeReducer");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const LivePreviewProvider = (props)=>{
    const { breakpoints, children, isPopupOpen, openPopupWindow, popupRef, url } = props;
    const [previewWindowType, setPreviewWindowType] = (0, _react.useState)('iframe');
    const [appIsReady, setAppIsReady] = (0, _react.useState)(false);
    const iframeRef = _react.default.useRef(null);
    const [iframeHasLoaded, setIframeHasLoaded] = (0, _react.useState)(false);
    const [zoom, setZoom] = (0, _react.useState)(1);
    const [position, setPosition] = (0, _react.useState)({
        x: 0,
        y: 0
    });
    const [size, setSize] = _react.default.useReducer(_sizeReducer.sizeReducer, {
        height: 0,
        width: 0
    });
    const [measuredDeviceSize, setMeasuredDeviceSize] = (0, _react.useState)({
        height: 0,
        width: 0
    });
    const [breakpoint, setBreakpoint] = _react.default.useState('responsive');
    const [fieldSchemaJSON] = (0, _react.useState)(()=>{
        let fields;
        if ('collection' in props) {
            const { collection } = props;
            fields = collection.fields;
        }
        if ('global' in props) {
            const { global } = props;
            fields = global.fields;
        }
        return (0, _fieldSchemaToJSON.fieldSchemaToJSON)(fields);
    });
    // The toolbar needs to freely drag and drop around the page
    const handleDragEnd = (ev)=>{
        // only update position if the toolbar is completely within the preview area
        // otherwise reset it back to the previous position
        // TODO: reset to the nearest edge of the preview area
        if (ev.over && ev.over.id === 'live-preview-area') {
            const newPos = {
                x: position.x + ev.delta.x,
                y: position.y + ev.delta.y
            };
            setPosition(newPos);
        } else {
        // reset
        }
    };
    const setWidth = (0, _react.useCallback)((width)=>{
        setSize({
            type: 'width',
            value: width
        });
    }, [
        setSize
    ]);
    const setHeight = (0, _react.useCallback)((height)=>{
        setSize({
            type: 'height',
            value: height
        });
    }, [
        setSize
    ]);
    // explicitly set new width and height when as new breakpoints are selected
    // exclude `custom` breakpoint as it is handled by the `setWidth` and `setHeight` directly
    (0, _react.useEffect)(()=>{
        const foundBreakpoint = breakpoints?.find((bp)=>bp.name === breakpoint);
        if (foundBreakpoint && breakpoint !== 'responsive' && breakpoint !== 'custom' && typeof foundBreakpoint?.width === 'number' && typeof foundBreakpoint?.height === 'number') {
            setSize({
                type: 'reset',
                value: {
                    height: foundBreakpoint.height,
                    width: foundBreakpoint.width
                }
            });
        }
    }, [
        breakpoint,
        breakpoints
    ]);
    // Receive the `ready` message from the popup window
    // This indicates that the app is ready to receive `window.postMessage` events
    // This is also the only cross-origin way of detecting when a popup window has loaded
    // Unlike iframe elements which have an `onLoad` handler, there is no way to access `window.open` on popups
    (0, _react.useEffect)(()=>{
        const handleMessage = (event)=>{
            if (url.startsWith(event.origin)) {
                const data = JSON.parse(event.data);
                if (data.type === 'payload-live-preview' && data.ready) {
                    setAppIsReady(true);
                }
            }
        };
        window.addEventListener('message', handleMessage);
        return ()=>{
            window.removeEventListener('message', handleMessage);
        };
    }, [
        url
    ]);
    const handleWindowChange = (0, _react.useCallback)((type)=>{
        setAppIsReady(false);
        setPreviewWindowType(type);
        if (type === 'popup') openPopupWindow();
    }, [
        openPopupWindow
    ]);
    // when the user closes the popup window, switch back to the iframe
    // the `usePopupWindow` reports the `isPopupOpen` state for us to use here
    (0, _react.useEffect)(()=>{
        if (!isPopupOpen) {
            handleWindowChange('iframe');
        }
    }, [
        isPopupOpen,
        handleWindowChange
    ]);
    return /*#__PURE__*/ _react.default.createElement(_context.LivePreviewContext.Provider, {
        value: {
            appIsReady,
            breakpoint,
            breakpoints,
            fieldSchemaJSON,
            iframeHasLoaded,
            iframeRef,
            isPopupOpen,
            measuredDeviceSize,
            openPopupWindow,
            popupRef,
            previewWindowType,
            setAppIsReady,
            setBreakpoint,
            setHeight,
            setIframeHasLoaded,
            setMeasuredDeviceSize,
            setPreviewWindowType: handleWindowChange,
            setSize,
            setToolbarPosition: setPosition,
            setWidth,
            setZoom,
            size,
            toolbarPosition: position,
            url,
            zoom
        }
    }, /*#__PURE__*/ _react.default.createElement(_core.DndContext, {
        collisionDetection: _collisionDetection.customCollisionDetection,
        onDragEnd: handleDragEnd
    }, children));
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL3ZpZXdzL0xpdmVQcmV2aWV3L0NvbnRleHQvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERuZENvbnRleHQgfSBmcm9tICdAZG5kLWtpdC9jb3JlJ1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHR5cGUgeyBMaXZlUHJldmlld0NvbmZpZyB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2V4cG9ydHMvY29uZmlnJ1xuaW1wb3J0IHR5cGUgeyBGaWVsZCB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2ZpZWxkcy9jb25maWcvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IEVkaXRWaWV3UHJvcHMgfSBmcm9tICcuLi8uLi90eXBlcydcbmltcG9ydCB0eXBlIHsgdXNlUG9wdXBXaW5kb3cgfSBmcm9tICcuLi91c2VQb3B1cFdpbmRvdydcblxuaW1wb3J0IHsgZmllbGRTY2hlbWFUb0pTT04gfSBmcm9tICcuLi8uLi8uLi8uLi8uLi91dGlsaXRpZXMvZmllbGRTY2hlbWFUb0pTT04nXG5pbXBvcnQgeyBjdXN0b21Db2xsaXNpb25EZXRlY3Rpb24gfSBmcm9tICcuL2NvbGxpc2lvbkRldGVjdGlvbidcbmltcG9ydCB7IExpdmVQcmV2aWV3Q29udGV4dCB9IGZyb20gJy4vY29udGV4dCdcbmltcG9ydCB7IHNpemVSZWR1Y2VyIH0gZnJvbSAnLi9zaXplUmVkdWNlcidcblxuZXhwb3J0IHR5cGUgTGl2ZVByZXZpZXdQcm92aWRlclByb3BzID0gRWRpdFZpZXdQcm9wcyAmIHtcbiAgYXBwSXNSZWFkeT86IGJvb2xlYW5cbiAgYnJlYWtwb2ludHM/OiBMaXZlUHJldmlld0NvbmZpZ1snYnJlYWtwb2ludHMnXVxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG4gIGRldmljZVNpemU/OiB7XG4gICAgaGVpZ2h0OiBudW1iZXJcbiAgICB3aWR0aDogbnVtYmVyXG4gIH1cbiAgaXNQb3B1cE9wZW4/OiBib29sZWFuXG4gIG9wZW5Qb3B1cFdpbmRvdz86IFJldHVyblR5cGU8dHlwZW9mIHVzZVBvcHVwV2luZG93Plsnb3BlblBvcHVwV2luZG93J11cbiAgcG9wdXBSZWY/OiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PFdpbmRvdz5cbiAgdXJsPzogc3RyaW5nXG59XG5cbmV4cG9ydCBjb25zdCBMaXZlUHJldmlld1Byb3ZpZGVyOiBSZWFjdC5GQzxMaXZlUHJldmlld1Byb3ZpZGVyUHJvcHM+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgYnJlYWtwb2ludHMsIGNoaWxkcmVuLCBpc1BvcHVwT3Blbiwgb3BlblBvcHVwV2luZG93LCBwb3B1cFJlZiwgdXJsIH0gPSBwcm9wc1xuXG4gIGNvbnN0IFtwcmV2aWV3V2luZG93VHlwZSwgc2V0UHJldmlld1dpbmRvd1R5cGVdID0gdXNlU3RhdGU8J2lmcmFtZScgfCAncG9wdXAnPignaWZyYW1lJylcblxuICBjb25zdCBbYXBwSXNSZWFkeSwgc2V0QXBwSXNSZWFkeV0gPSB1c2VTdGF0ZShmYWxzZSlcblxuICBjb25zdCBpZnJhbWVSZWYgPSBSZWFjdC51c2VSZWY8SFRNTElGcmFtZUVsZW1lbnQ+KG51bGwpXG5cbiAgY29uc3QgW2lmcmFtZUhhc0xvYWRlZCwgc2V0SWZyYW1lSGFzTG9hZGVkXSA9IHVzZVN0YXRlKGZhbHNlKVxuXG4gIGNvbnN0IFt6b29tLCBzZXRab29tXSA9IHVzZVN0YXRlKDEpXG5cbiAgY29uc3QgW3Bvc2l0aW9uLCBzZXRQb3NpdGlvbl0gPSB1c2VTdGF0ZSh7IHg6IDAsIHk6IDAgfSlcblxuICBjb25zdCBbc2l6ZSwgc2V0U2l6ZV0gPSBSZWFjdC51c2VSZWR1Y2VyKHNpemVSZWR1Y2VyLCB7IGhlaWdodDogMCwgd2lkdGg6IDAgfSlcblxuICBjb25zdCBbbWVhc3VyZWREZXZpY2VTaXplLCBzZXRNZWFzdXJlZERldmljZVNpemVdID0gdXNlU3RhdGUoe1xuICAgIGhlaWdodDogMCxcbiAgICB3aWR0aDogMCxcbiAgfSlcblxuICBjb25zdCBbYnJlYWtwb2ludCwgc2V0QnJlYWtwb2ludF0gPVxuICAgIFJlYWN0LnVzZVN0YXRlPExpdmVQcmV2aWV3Q29uZmlnWydicmVha3BvaW50cyddWzBdWyduYW1lJ10+KCdyZXNwb25zaXZlJylcblxuICBjb25zdCBbZmllbGRTY2hlbWFKU09OXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICBsZXQgZmllbGRzOiBGaWVsZFtdXG5cbiAgICBpZiAoJ2NvbGxlY3Rpb24nIGluIHByb3BzKSB7XG4gICAgICBjb25zdCB7IGNvbGxlY3Rpb24gfSA9IHByb3BzXG4gICAgICBmaWVsZHMgPSBjb2xsZWN0aW9uLmZpZWxkc1xuICAgIH1cblxuICAgIGlmICgnZ2xvYmFsJyBpbiBwcm9wcykge1xuICAgICAgY29uc3QgeyBnbG9iYWwgfSA9IHByb3BzXG4gICAgICBmaWVsZHMgPSBnbG9iYWwuZmllbGRzXG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkU2NoZW1hVG9KU09OKGZpZWxkcylcbiAgfSlcblxuICAvLyBUaGUgdG9vbGJhciBuZWVkcyB0byBmcmVlbHkgZHJhZyBhbmQgZHJvcCBhcm91bmQgdGhlIHBhZ2VcbiAgY29uc3QgaGFuZGxlRHJhZ0VuZCA9IChldikgPT4ge1xuICAgIC8vIG9ubHkgdXBkYXRlIHBvc2l0aW9uIGlmIHRoZSB0b29sYmFyIGlzIGNvbXBsZXRlbHkgd2l0aGluIHRoZSBwcmV2aWV3IGFyZWFcbiAgICAvLyBvdGhlcndpc2UgcmVzZXQgaXQgYmFjayB0byB0aGUgcHJldmlvdXMgcG9zaXRpb25cbiAgICAvLyBUT0RPOiByZXNldCB0byB0aGUgbmVhcmVzdCBlZGdlIG9mIHRoZSBwcmV2aWV3IGFyZWFcbiAgICBpZiAoZXYub3ZlciAmJiBldi5vdmVyLmlkID09PSAnbGl2ZS1wcmV2aWV3LWFyZWEnKSB7XG4gICAgICBjb25zdCBuZXdQb3MgPSB7XG4gICAgICAgIHg6IHBvc2l0aW9uLnggKyBldi5kZWx0YS54LFxuICAgICAgICB5OiBwb3NpdGlvbi55ICsgZXYuZGVsdGEueSxcbiAgICAgIH1cblxuICAgICAgc2V0UG9zaXRpb24obmV3UG9zKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXNldFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNldFdpZHRoID0gdXNlQ2FsbGJhY2soXG4gICAgKHdpZHRoKSA9PiB7XG4gICAgICBzZXRTaXplKHsgdHlwZTogJ3dpZHRoJywgdmFsdWU6IHdpZHRoIH0pXG4gICAgfSxcbiAgICBbc2V0U2l6ZV0sXG4gIClcblxuICBjb25zdCBzZXRIZWlnaHQgPSB1c2VDYWxsYmFjayhcbiAgICAoaGVpZ2h0KSA9PiB7XG4gICAgICBzZXRTaXplKHsgdHlwZTogJ2hlaWdodCcsIHZhbHVlOiBoZWlnaHQgfSlcbiAgICB9LFxuICAgIFtzZXRTaXplXSxcbiAgKVxuXG4gIC8vIGV4cGxpY2l0bHkgc2V0IG5ldyB3aWR0aCBhbmQgaGVpZ2h0IHdoZW4gYXMgbmV3IGJyZWFrcG9pbnRzIGFyZSBzZWxlY3RlZFxuICAvLyBleGNsdWRlIGBjdXN0b21gIGJyZWFrcG9pbnQgYXMgaXQgaXMgaGFuZGxlZCBieSB0aGUgYHNldFdpZHRoYCBhbmQgYHNldEhlaWdodGAgZGlyZWN0bHlcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBmb3VuZEJyZWFrcG9pbnQgPSBicmVha3BvaW50cz8uZmluZCgoYnApID0+IGJwLm5hbWUgPT09IGJyZWFrcG9pbnQpXG5cbiAgICBpZiAoXG4gICAgICBmb3VuZEJyZWFrcG9pbnQgJiZcbiAgICAgIGJyZWFrcG9pbnQgIT09ICdyZXNwb25zaXZlJyAmJlxuICAgICAgYnJlYWtwb2ludCAhPT0gJ2N1c3RvbScgJiZcbiAgICAgIHR5cGVvZiBmb3VuZEJyZWFrcG9pbnQ/LndpZHRoID09PSAnbnVtYmVyJyAmJlxuICAgICAgdHlwZW9mIGZvdW5kQnJlYWtwb2ludD8uaGVpZ2h0ID09PSAnbnVtYmVyJ1xuICAgICkge1xuICAgICAgc2V0U2l6ZSh7XG4gICAgICAgIHR5cGU6ICdyZXNldCcsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgaGVpZ2h0OiBmb3VuZEJyZWFrcG9pbnQuaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBmb3VuZEJyZWFrcG9pbnQud2lkdGgsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH1cbiAgfSwgW2JyZWFrcG9pbnQsIGJyZWFrcG9pbnRzXSlcblxuICAvLyBSZWNlaXZlIHRoZSBgcmVhZHlgIG1lc3NhZ2UgZnJvbSB0aGUgcG9wdXAgd2luZG93XG4gIC8vIFRoaXMgaW5kaWNhdGVzIHRoYXQgdGhlIGFwcCBpcyByZWFkeSB0byByZWNlaXZlIGB3aW5kb3cucG9zdE1lc3NhZ2VgIGV2ZW50c1xuICAvLyBUaGlzIGlzIGFsc28gdGhlIG9ubHkgY3Jvc3Mtb3JpZ2luIHdheSBvZiBkZXRlY3Rpbmcgd2hlbiBhIHBvcHVwIHdpbmRvdyBoYXMgbG9hZGVkXG4gIC8vIFVubGlrZSBpZnJhbWUgZWxlbWVudHMgd2hpY2ggaGF2ZSBhbiBgb25Mb2FkYCBoYW5kbGVyLCB0aGVyZSBpcyBubyB3YXkgdG8gYWNjZXNzIGB3aW5kb3cub3BlbmAgb24gcG9wdXBzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlTWVzc2FnZSA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoZXZlbnQub3JpZ2luKSkge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxuXG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdwYXlsb2FkLWxpdmUtcHJldmlldycgJiYgZGF0YS5yZWFkeSkge1xuICAgICAgICAgIHNldEFwcElzUmVhZHkodHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSlcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpXG4gICAgfVxuICB9LCBbdXJsXSlcblxuICBjb25zdCBoYW5kbGVXaW5kb3dDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAgICAodHlwZTogJ2lmcmFtZScgfCAncG9wdXAnKSA9PiB7XG4gICAgICBzZXRBcHBJc1JlYWR5KGZhbHNlKVxuICAgICAgc2V0UHJldmlld1dpbmRvd1R5cGUodHlwZSlcbiAgICAgIGlmICh0eXBlID09PSAncG9wdXAnKSBvcGVuUG9wdXBXaW5kb3coKVxuICAgIH0sXG4gICAgW29wZW5Qb3B1cFdpbmRvd10sXG4gIClcblxuICAvLyB3aGVuIHRoZSB1c2VyIGNsb3NlcyB0aGUgcG9wdXAgd2luZG93LCBzd2l0Y2ggYmFjayB0byB0aGUgaWZyYW1lXG4gIC8vIHRoZSBgdXNlUG9wdXBXaW5kb3dgIHJlcG9ydHMgdGhlIGBpc1BvcHVwT3BlbmAgc3RhdGUgZm9yIHVzIHRvIHVzZSBoZXJlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc1BvcHVwT3Blbikge1xuICAgICAgaGFuZGxlV2luZG93Q2hhbmdlKCdpZnJhbWUnKVxuICAgIH1cbiAgfSwgW2lzUG9wdXBPcGVuLCBoYW5kbGVXaW5kb3dDaGFuZ2VdKVxuXG4gIHJldHVybiAoXG4gICAgPExpdmVQcmV2aWV3Q29udGV4dC5Qcm92aWRlclxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgYXBwSXNSZWFkeSxcbiAgICAgICAgYnJlYWtwb2ludCxcbiAgICAgICAgYnJlYWtwb2ludHMsXG4gICAgICAgIGZpZWxkU2NoZW1hSlNPTixcbiAgICAgICAgaWZyYW1lSGFzTG9hZGVkLFxuICAgICAgICBpZnJhbWVSZWYsXG4gICAgICAgIGlzUG9wdXBPcGVuLFxuICAgICAgICBtZWFzdXJlZERldmljZVNpemUsXG4gICAgICAgIG9wZW5Qb3B1cFdpbmRvdyxcbiAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgIHByZXZpZXdXaW5kb3dUeXBlLFxuICAgICAgICBzZXRBcHBJc1JlYWR5LFxuICAgICAgICBzZXRCcmVha3BvaW50LFxuICAgICAgICBzZXRIZWlnaHQsXG4gICAgICAgIHNldElmcmFtZUhhc0xvYWRlZCxcbiAgICAgICAgc2V0TWVhc3VyZWREZXZpY2VTaXplLFxuICAgICAgICBzZXRQcmV2aWV3V2luZG93VHlwZTogaGFuZGxlV2luZG93Q2hhbmdlLFxuICAgICAgICBzZXRTaXplLFxuICAgICAgICBzZXRUb29sYmFyUG9zaXRpb246IHNldFBvc2l0aW9uLFxuICAgICAgICBzZXRXaWR0aCxcbiAgICAgICAgc2V0Wm9vbSxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgdG9vbGJhclBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgdXJsLFxuICAgICAgICB6b29tLFxuICAgICAgfX1cbiAgICA+XG4gICAgICA8RG5kQ29udGV4dCBjb2xsaXNpb25EZXRlY3Rpb249e2N1c3RvbUNvbGxpc2lvbkRldGVjdGlvbn0gb25EcmFnRW5kPXtoYW5kbGVEcmFnRW5kfT5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9EbmRDb250ZXh0PlxuICAgIDwvTGl2ZVByZXZpZXdDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG4iXSwibmFtZXMiOlsiTGl2ZVByZXZpZXdQcm92aWRlciIsInByb3BzIiwiYnJlYWtwb2ludHMiLCJjaGlsZHJlbiIsImlzUG9wdXBPcGVuIiwib3BlblBvcHVwV2luZG93IiwicG9wdXBSZWYiLCJ1cmwiLCJwcmV2aWV3V2luZG93VHlwZSIsInNldFByZXZpZXdXaW5kb3dUeXBlIiwidXNlU3RhdGUiLCJhcHBJc1JlYWR5Iiwic2V0QXBwSXNSZWFkeSIsImlmcmFtZVJlZiIsIlJlYWN0IiwidXNlUmVmIiwiaWZyYW1lSGFzTG9hZGVkIiwic2V0SWZyYW1lSGFzTG9hZGVkIiwiem9vbSIsInNldFpvb20iLCJwb3NpdGlvbiIsInNldFBvc2l0aW9uIiwieCIsInkiLCJzaXplIiwic2V0U2l6ZSIsInVzZVJlZHVjZXIiLCJzaXplUmVkdWNlciIsImhlaWdodCIsIndpZHRoIiwibWVhc3VyZWREZXZpY2VTaXplIiwic2V0TWVhc3VyZWREZXZpY2VTaXplIiwiYnJlYWtwb2ludCIsInNldEJyZWFrcG9pbnQiLCJmaWVsZFNjaGVtYUpTT04iLCJmaWVsZHMiLCJjb2xsZWN0aW9uIiwiZ2xvYmFsIiwiZmllbGRTY2hlbWFUb0pTT04iLCJoYW5kbGVEcmFnRW5kIiwiZXYiLCJvdmVyIiwiaWQiLCJuZXdQb3MiLCJkZWx0YSIsInNldFdpZHRoIiwidXNlQ2FsbGJhY2siLCJ0eXBlIiwidmFsdWUiLCJzZXRIZWlnaHQiLCJ1c2VFZmZlY3QiLCJmb3VuZEJyZWFrcG9pbnQiLCJmaW5kIiwiYnAiLCJuYW1lIiwiaGFuZGxlTWVzc2FnZSIsImV2ZW50Iiwic3RhcnRzV2l0aCIsIm9yaWdpbiIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJyZWFkeSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlV2luZG93Q2hhbmdlIiwiTGl2ZVByZXZpZXdDb250ZXh0IiwiUHJvdmlkZXIiLCJzZXRUb29sYmFyUG9zaXRpb24iLCJ0b29sYmFyUG9zaXRpb24iLCJEbmRDb250ZXh0IiwiY29sbGlzaW9uRGV0ZWN0aW9uIiwiY3VzdG9tQ29sbGlzaW9uRGV0ZWN0aW9uIiwib25EcmFnRW5kIl0sIm1hcHBpbmdzIjoiOzs7OytCQTJCYUE7OztlQUFBQTs7O3NCQTNCYzsrREFDcUM7bUNBTzlCO29DQUNPO3lCQUNOOzZCQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JyQixNQUFNQSxzQkFBMEQsQ0FBQ0M7SUFDdEUsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLFFBQVEsRUFBRUMsV0FBVyxFQUFFQyxlQUFlLEVBQUVDLFFBQVEsRUFBRUMsR0FBRyxFQUFFLEdBQUdOO0lBRS9FLE1BQU0sQ0FBQ08sbUJBQW1C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