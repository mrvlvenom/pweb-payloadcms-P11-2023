/* eslint-disable no-param-reassign */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "promise", {
    enumerable: true,
    get: function() {
        return promise;
    }
});
const _types = require("../../config/types");
const _relationshipPopulationPromise = /*#__PURE__*/ _interop_require_default(require("./relationshipPopulationPromise"));
const _traverseFields = require("./traverseFields");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const promise = async ({ collection, context, currentDepth, depth, doc, field, fieldPromises, findMany, flattenLocales, global, overrideAccess, populationPromises, req, showHiddenFields, siblingDoc })=>{
    if ((0, _types.fieldAffectsData)(field) && field.hidden && typeof siblingDoc[field.name] !== 'undefined' && !showHiddenFields) {
        delete siblingDoc[field.name];
    }
    const shouldHoistLocalizedValue = flattenLocales && (0, _types.fieldAffectsData)(field) && typeof siblingDoc[field.name] === 'object' && siblingDoc[field.name] !== null && field.localized && req.locale !== 'all' && req.payload.config.localization;
    if (shouldHoistLocalizedValue) {
        // replace actual value with localized value before sanitizing
        // { [locale]: fields } -> fields
        const { locale } = req;
        const value = siblingDoc[field.name][locale];
        const fallbackLocale = req.payload.config.localization && req.payload.config.localization?.fallback && req.fallbackLocale;
        let hoistedValue = value;
        if (fallbackLocale && fallbackLocale !== locale) {
            const fallbackValue = siblingDoc[field.name][fallbackLocale];
            const isNullOrUndefined = typeof value === 'undefined' || value === null;
            if (fallbackValue) {
                switch(field.type){
                    case 'text':
                    case 'textarea':
                        {
                            if (value === '' || isNullOrUndefined) {
                                hoistedValue = fallbackValue;
                            }
                            break;
                        }
                    default:
                        {
                            if (isNullOrUndefined) {
                                hoistedValue = fallbackValue;
                            }
                            break;
                        }
                }
            }
        }
        siblingDoc[field.name] = hoistedValue;
    }
    // Sanitize outgoing field value
    switch(field.type){
        case 'group':
            {
                // Fill groups with empty objects so fields with hooks within groups can populate
                // themselves virtually as necessary
                if (typeof siblingDoc[field.name] === 'undefined') {
                    siblingDoc[field.name] = {};
                }
                break;
            }
        case 'tabs':
            {
                field.tabs.forEach((tab)=>{
                    if ((0, _types.tabHasName)(tab) && (typeof siblingDoc[tab.name] === 'undefined' || siblingDoc[tab.name] === null)) {
                        siblingDoc[tab.name] = {};
                    }
                });
                break;
            }
        case 'richText':
            {
                const editor = field?.editor;
                // This is run here AND in the GraphQL Resolver
                if (editor?.populationPromise) {
                    const populationPromise = editor.populationPromise({
                        currentDepth,
                        depth,
                        field,
                        overrideAccess,
                        req,
                        showHiddenFields,
                        siblingDoc
                    });
                    if (populationPromise) {
                        populationPromises.push(populationPromise);
                    }
                }
                // This is only run here, independent of depth
                if (editor?.afterReadPromise) {
                    const afterReadPromise = editor?.afterReadPromise({
                        field,
                        incomingEditorState: siblingDoc[field.name],
                        siblingDoc
                    });
                    if (afterReadPromise) {
                        populationPromises.push(afterReadPromise);
                    }
                }
                break;
            }
        case 'point':
            {
                const pointDoc = siblingDoc[field.name];
                if (Array.isArray(pointDoc?.coordinates) && pointDoc.coordinates.length === 2) {
                    siblingDoc[field.name] = pointDoc.coordinates;
                } else {
                    siblingDoc[field.name] = undefined;
                }
                break;
            }
        default:
            {
                break;
            }
    }
    if ((0, _types.fieldAffectsData)(field)) {
        // Execute hooks
        if (field.hooks?.afterRead) {
            await field.hooks.afterRead.reduce(async (priorHook, currentHook)=>{
                await priorHook;
                const shouldRunHookOnAllLocales = field.localized && (req.locale === 'all' || !flattenLocales) && typeof siblingDoc[field.name] === 'object';
                if (shouldRunHookOnAllLocales) {
                    const hookPromises = Object.entries(siblingDoc[field.name]).map(([locale, value])=>(async ()=>{
                            const hookedValue = await currentHook({
                                collection,
                                context,
                                data: doc,
                                field,
                                global,
                                operation: 'read',
                                originalDoc: doc,
                                req,
                                siblingData: siblingDoc,
                                value
                            });
                            if (hookedValue !== undefined) {
                                siblingDoc[field.name][locale] = hookedValue;
                            }
                        })());
                    await Promise.all(hookPromises);
                } else {
                    const hookedValue = await currentHook({
                        collection,
                        context,
                        data: doc,
                        field,
                        findMany,
                        global,
                        operation: 'read',
                        originalDoc: doc,
                        req,
                        siblingData: siblingDoc,
                        value: siblingDoc[field.name]
                    });
                    if (hookedValue !== undefined) {
                        siblingDoc[field.name] = hookedValue;
                    }
                }
            }, Promise.resolve());
        }
        // Execute access control
        if (field.access && field.access.read) {
            const result = overrideAccess ? true : await field.access.read({
                id: doc.id,
                data: doc,
                doc,
                req,
                siblingData: siblingDoc
            });
            if (!result) {
                delete siblingDoc[field.name];
            }
        }
        if (field.type === 'relationship' || field.type === 'upload') {
            populationPromises.push((0, _relationshipPopulationPromise.default)({
                currentDepth,
                depth,
                field,
                overrideAccess,
                req,
                showHiddenFields,
                siblingDoc
            }));
        }
    }
    switch(field.type){
        case 'group':
            {
                let groupDoc = siblingDoc[field.name];
                if (typeof siblingDoc[field.name] !== 'object') groupDoc = {};
                (0, _traverseFields.traverseFields)({
                    collection,
                    context,
                    currentDepth,
                    depth,
                    doc,
                    fieldPromises,
                    fields: field.fields,
                    findMany,
                    flattenLocales,
                    global,
                    overrideAccess,
                    populationPromises,
                    req,
                    showHiddenFields,
                    siblingDoc: groupDoc
                });
                break;
            }
        case 'array':
            {
                const rows = siblingDoc[field.name];
                if (Array.isArray(rows)) {
                    rows.forEach((row)=>{
                        (0, _traverseFields.traverseFields)({
                            collection,
                            context,
                            currentDepth,
                            depth,
                            doc,
                            fieldPromises,
                            fields: field.fields,
                            findMany,
                            flattenLocales,
                            global,
                            overrideAccess,
                            populationPromises,
                            req,
                            showHiddenFields,
                            siblingDoc: row || {}
                        });
                    });
                } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {
                    Object.values(rows).forEach((localeRows)=>{
                        if (Array.isArray(localeRows)) {
                            localeRows.forEach((row)=>{
                                (0, _traverseFields.traverseFields)({
                                    collection,
                                    context,
                                    currentDepth,
                                    depth,
                                    doc,
                                    fieldPromises,
                                    fields: field.fields,
                                    findMany,
                                    flattenLocales,
                                    global,
                                    overrideAccess,
                                    populationPromises,
                                    req,
                                    showHiddenFields,
                                    siblingDoc: row || {}
                                });
                            });
                        }
                    });
                } else {
                    siblingDoc[field.name] = [];
                }
                break;
            }
        case 'blocks':
            {
                const rows = siblingDoc[field.name];
                if (Array.isArray(rows)) {
                    rows.forEach((row)=>{
                        const block = field.blocks.find((blockType)=>blockType.slug === row.blockType);
                        if (block) {
                            (0, _traverseFields.traverseFields)({
                                collection,
                                context,
                                currentDepth,
                                depth,
                                doc,
                                fieldPromises,
                                fields: block.fields,
                                findMany,
                                flattenLocales,
                                global,
                                overrideAccess,
                                populationPromises,
                                req,
                                showHiddenFields,
                                siblingDoc: row || {}
                            });
                        }
                    });
                } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {
                    Object.values(rows).forEach((localeRows)=>{
                        if (Array.isArray(localeRows)) {
                            localeRows.forEach((row)=>{
                                const block = field.blocks.find((blockType)=>blockType.slug === row.blockType);
                                if (block) {
                                    (0, _traverseFields.traverseFields)({
                                        collection,
                                        context,
                                        currentDepth,
                                        depth,
                                        doc,
                                        fieldPromises,
                                        fields: block.fields,
                                        findMany,
                                        flattenLocales,
                                        global,
                                        overrideAccess,
                                        populationPromises,
                                        req,
                                        showHiddenFields,
                                        siblingDoc: row || {}
                                    });
                                }
                            });
                        }
                    });
                } else {
                    siblingDoc[field.name] = [];
                }
                break;
            }
        case 'row':
        case 'collapsible':
            {
                (0, _traverseFields.traverseFields)({
                    collection,
                    context,
                    currentDepth,
                    depth,
                    doc,
                    fieldPromises,
                    fields: field.fields,
                    findMany,
                    flattenLocales,
                    global,
                    overrideAccess,
                    populationPromises,
                    req,
                    showHiddenFields,
                    siblingDoc
                });
                break;
            }
        case 'tab':
            {
                let tabDoc = siblingDoc;
                if ((0, _types.tabHasName)(field)) {
                    tabDoc = siblingDoc[field.name];
                    if (typeof siblingDoc[field.name] !== 'object') tabDoc = {};
                }
                await (0, _traverseFields.traverseFields)({
                    collection,
                    context,
                    currentDepth,
                    depth,
                    doc,
                    fieldPromises,
                    fields: field.fields,
                    findMany,
                    flattenLocales,
                    global,
                    overrideAccess,
                    populationPromises,
                    req,
                    showHiddenFields,
                    siblingDoc: tabDoc
                });
                break;
            }
        case 'tabs':
            {
                (0, _traverseFields.traverseFields)({
                    collection,
                    context,
                    currentDepth,
                    depth,
                    doc,
                    fieldPromises,
                    fields: field.tabs.map((tab)=>({
                            ...tab,
                            type: 'tab'
                        })),
                    findMany,
                    flattenLocales,
                    global,
                    overrideAccess,
                    populationPromises,
                    req,
                    showHiddenFields,
                    siblingDoc
                });
                break;
            }
        default:
            {
                break;
            }
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9maWVsZHMvaG9va3MvYWZ0ZXJSZWFkL3Byb21pc2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbmltcG9ydCB0eXBlIHsgUmljaFRleHRBZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vYWRtaW4vY29tcG9uZW50cy9mb3Jtcy9maWVsZC10eXBlcy9SaWNoVGV4dC90eXBlcydcbmltcG9ydCB0eXBlIHsgU2FuaXRpemVkQ29sbGVjdGlvbkNvbmZpZyB9IGZyb20gJy4uLy4uLy4uL2NvbGxlY3Rpb25zL2NvbmZpZy90eXBlcydcbmltcG9ydCB0eXBlIHsgUGF5bG9hZFJlcXVlc3QsIFJlcXVlc3RDb250ZXh0IH0gZnJvbSAnLi4vLi4vLi4vZXhwcmVzcy90eXBlcydcbmltcG9ydCB0eXBlIHsgU2FuaXRpemVkR2xvYmFsQ29uZmlnIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscy9jb25maWcvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IEZpZWxkLCBUYWJBc0ZpZWxkIH0gZnJvbSAnLi4vLi4vY29uZmlnL3R5cGVzJ1xuXG5pbXBvcnQgeyBmaWVsZEFmZmVjdHNEYXRhLCB0YWJIYXNOYW1lIH0gZnJvbSAnLi4vLi4vY29uZmlnL3R5cGVzJ1xuaW1wb3J0IHJlbGF0aW9uc2hpcFBvcHVsYXRpb25Qcm9taXNlIGZyb20gJy4vcmVsYXRpb25zaGlwUG9wdWxhdGlvblByb21pc2UnXG5pbXBvcnQgeyB0cmF2ZXJzZUZpZWxkcyB9IGZyb20gJy4vdHJhdmVyc2VGaWVsZHMnXG5cbnR5cGUgQXJncyA9IHtcbiAgY29sbGVjdGlvbjogU2FuaXRpemVkQ29sbGVjdGlvbkNvbmZpZyB8IG51bGxcbiAgY29udGV4dDogUmVxdWVzdENvbnRleHRcbiAgY3VycmVudERlcHRoOiBudW1iZXJcbiAgZGVwdGg6IG51bWJlclxuICBkb2M6IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gIGZpZWxkOiBGaWVsZCB8IFRhYkFzRmllbGRcbiAgZmllbGRQcm9taXNlczogUHJvbWlzZTx2b2lkPltdXG4gIGZpbmRNYW55OiBib29sZWFuXG4gIGZsYXR0ZW5Mb2NhbGVzOiBib29sZWFuXG4gIGdsb2JhbDogU2FuaXRpemVkR2xvYmFsQ29uZmlnIHwgbnVsbFxuICBvdmVycmlkZUFjY2VzczogYm9vbGVhblxuICBwb3B1bGF0aW9uUHJvbWlzZXM6IFByb21pc2U8dm9pZD5bXVxuICByZXE6IFBheWxvYWRSZXF1ZXN0XG4gIHNob3dIaWRkZW5GaWVsZHM6IGJvb2xlYW5cbiAgc2libGluZ0RvYzogUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgdGhlIGZvbGxvd2luZyBhY3Rpb25zLCBpbiBvcmRlcjpcbi8vIC0gUmVtb3ZlIGhpZGRlbiBmaWVsZHMgZnJvbSByZXNwb25zZVxuLy8gLSBGbGF0dGVuIGxvY2FsZXMgaW50byByZXF1ZXN0ZWQgbG9jYWxlXG4vLyAtIFNhbml0aXplIG91dGdvaW5nIGRhdGEgKHBvaW50IGZpZWxkLCBldGMpXG4vLyAtIEV4ZWN1dGUgZmllbGQgaG9va3Ncbi8vIC0gRXhlY3V0ZSByZWFkIGFjY2VzcyBjb250cm9sXG4vLyAtIFBvcHVsYXRlIHJlbGF0aW9uc2hpcHNcblxuZXhwb3J0IGNvbnN0IHByb21pc2UgPSBhc3luYyAoe1xuICBjb2xsZWN0aW9uLFxuICBjb250ZXh0LFxuICBjdXJyZW50RGVwdGgsXG4gIGRlcHRoLFxuICBkb2MsXG4gIGZpZWxkLFxuICBmaWVsZFByb21pc2VzLFxuICBmaW5kTWFueSxcbiAgZmxhdHRlbkxvY2FsZXMsXG4gIGdsb2JhbCxcbiAgb3ZlcnJpZGVBY2Nlc3MsXG4gIHBvcHVsYXRpb25Qcm9taXNlcyxcbiAgcmVxLFxuICBzaG93SGlkZGVuRmllbGRzLFxuICBzaWJsaW5nRG9jLFxufTogQXJncyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoXG4gICAgZmllbGRBZmZlY3RzRGF0YShmaWVsZCkgJiZcbiAgICBmaWVsZC5oaWRkZW4gJiZcbiAgICB0eXBlb2Ygc2libGluZ0RvY1tmaWVsZC5uYW1lXSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAhc2hvd0hpZGRlbkZpZWxkc1xuICApIHtcbiAgICBkZWxldGUgc2libGluZ0RvY1tmaWVsZC5uYW1lXVxuICB9XG5cbiAgY29uc3Qgc2hvdWxkSG9pc3RMb2NhbGl6ZWRWYWx1ZSA9XG4gICAgZmxhdHRlbkxvY2FsZXMgJiZcbiAgICBmaWVsZEFmZmVjdHNEYXRhKGZpZWxkKSAmJlxuICAgIHR5cGVvZiBzaWJsaW5nRG9jW2ZpZWxkLm5hbWVdID09PSAnb2JqZWN0JyAmJlxuICAgIHNpYmxpbmdEb2NbZmllbGQubmFtZV0gIT09IG51bGwgJiZcbiAgICBmaWVsZC5sb2NhbGl6ZWQgJiZcbiAgICByZXEubG9jYWxlICE9PSAnYWxsJyAmJlxuICAgIHJlcS5wYXlsb2FkLmNvbmZpZy5sb2NhbGl6YXRpb25cblxuICBpZiAoc2hvdWxkSG9pc3RMb2NhbGl6ZWRWYWx1ZSkge1xuICAgIC8vIHJlcGxhY2UgYWN0dWFsIHZhbHVlIHdpdGggbG9jYWxpemVkIHZhbHVlIGJlZm9yZSBzYW5pdGl6aW5nXG4gICAgLy8geyBbbG9jYWxlXTogZmllbGRzIH0gLT4gZmllbGRzXG4gICAgY29uc3QgeyBsb2NhbGUgfSA9IHJlcVxuICAgIGNvbnN0IHZhbHVlID0gc2libGluZ0RvY1tmaWVsZC5uYW1lXVtsb2NhbGVdXG4gICAgY29uc3QgZmFsbGJhY2tMb2NhbGUgPVxuICAgICAgcmVxLnBheWxvYWQuY29uZmlnLmxvY2FsaXphdGlvbiAmJlxuICAgICAgcmVxLnBheWxvYWQuY29uZmlnLmxvY2FsaXphdGlvbj8uZmFsbGJhY2sgJiZcbiAgICAgIHJlcS5mYWxsYmFja0xvY2FsZVxuXG4gICAgbGV0IGhvaXN0ZWRWYWx1ZSA9IHZhbHVlXG5cbiAgICBpZiAoZmFsbGJhY2tMb2NhbGUgJiYgZmFsbGJhY2tMb2NhbGUgIT09IGxvY2FsZSkge1xuICAgICAgY29uc3QgZmFsbGJhY2tWYWx1ZSA9IHNpYmxpbmdEb2NbZmllbGQubmFtZV1bZmFsbGJhY2tMb2NhbGVdXG4gICAgICBjb25zdCBpc051bGxPclVuZGVmaW5lZCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGxcblxuICAgICAgaWYgKGZhbGxiYWNrVmFsdWUpIHtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgY2FzZSAndGV4dGFyZWEnOiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICcnIHx8IGlzTnVsbE9yVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGhvaXN0ZWRWYWx1ZSA9IGZhbGxiYWNrVmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGhvaXN0ZWRWYWx1ZSA9IGZhbGxiYWNrVmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2libGluZ0RvY1tmaWVsZC5uYW1lXSA9IGhvaXN0ZWRWYWx1ZVxuICB9XG5cbiAgLy8gU2FuaXRpemUgb3V0Z29pbmcgZmllbGQgdmFsdWVcbiAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgY2FzZSAnZ3JvdXAnOiB7XG4gICAgICAvLyBGaWxsIGdyb3VwcyB3aXRoIGVtcHR5IG9iamVjdHMgc28gZmllbGRzIHdpdGggaG9va3Mgd2l0aGluIGdyb3VwcyBjYW4gcG9wdWxhdGVcbiAgICAgIC8vIHRoZW1zZWx2ZXMgdmlydHVhbGx5IGFzIG5lY2Vzc2FyeVxuICAgICAgaWYgKHR5cGVvZiBzaWJsaW5nRG9jW2ZpZWxkLm5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzaWJsaW5nRG9jW2ZpZWxkLm5hbWVdID0ge31cbiAgICAgIH1cblxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAndGFicyc6IHtcbiAgICAgIGZpZWxkLnRhYnMuZm9yRWFjaCgodGFiKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0YWJIYXNOYW1lKHRhYikgJiZcbiAgICAgICAgICAodHlwZW9mIHNpYmxpbmdEb2NbdGFiLm5hbWVdID09PSAndW5kZWZpbmVkJyB8fCBzaWJsaW5nRG9jW3RhYi5uYW1lXSA9PT0gbnVsbClcbiAgICAgICAgKSB7XG4gICAgICAgICAgc2libGluZ0RvY1t0YWIubmFtZV0gPSB7fVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGNhc2UgJ3JpY2hUZXh0Jzoge1xuICAgICAgY29uc3QgZWRpdG9yOiBSaWNoVGV4dEFkYXB0ZXIgPSBmaWVsZD8uZWRpdG9yXG4gICAgICAvLyBUaGlzIGlzIHJ1biBoZXJlIEFORCBpbiB0aGUgR3JhcGhRTCBSZXNvbHZlclxuICAgICAgaWYgKGVkaXRvcj8ucG9wdWxhdGlvblByb21pc2UpIHtcbiAgICAgICAgY29uc3QgcG9wdWxhdGlvblByb21pc2UgPSBlZGl0b3IucG9wdWxhdGlvblByb21pc2Uoe1xuICAgICAgICAgIGN1cnJlbnREZXB0aCxcbiAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICBvdmVycmlkZUFjY2VzcyxcbiAgICAgICAgICByZXEsXG4gICAgICAgICAgc2hvd0hpZGRlbkZpZWxkcyxcbiAgICAgICAgICBzaWJsaW5nRG9jLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChwb3B1bGF0aW9uUHJvbWlzZSkge1xuICAgICAgICAgIHBvcHVsYXRpb25Qcm9taXNlcy5wdXNoKHBvcHVsYXRpb25Qcm9taXNlKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgaXMgb25seSBydW4gaGVyZSwgaW5kZXBlbmRlbnQgb2YgZGVwdGhcbiAgICAgIGlmIChlZGl0b3I/LmFmdGVyUmVhZFByb21pc2UpIHtcbiAgICAgICAgY29uc3QgYWZ0ZXJSZWFkUHJvbWlzZSA9IGVkaXRvcj8uYWZ0ZXJSZWFkUHJvbWlzZSh7XG4gICAgICAgICAgZmllbGQsXG4gICAgICAgICAgaW5jb21pbmdFZGl0b3JTdGF0ZTogc2libGluZ0RvY1tmaWVsZC5uYW1lXSBhcyBvYmplY3QsXG4gICAgICAgICAgc2libGluZ0RvYyxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoYWZ0ZXJSZWFkUHJvbWlzZSkge1xuICAgICAgICAgIHBvcHVsYXRpb25Qcm9taXNlcy5wdXNoKGFmdGVyUmVhZFByb21pc2UpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBjYXNlICdwb2ludCc6IHtcbiAgICAgIGNvbnN0IHBvaW50RG9jID0gc2libGluZ0RvY1tmaWVsZC5uYW1lXSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9pbnREb2M/LmNvb3JkaW5hdGVzKSAmJiBwb2ludERvYy5jb29yZGluYXRlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgc2libGluZ0RvY1tmaWVsZC5uYW1lXSA9IHBvaW50RG9jLmNvb3JkaW5hdGVzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWJsaW5nRG9jW2ZpZWxkLm5hbWVdID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoZmllbGRBZmZlY3RzRGF0YShmaWVsZCkpIHtcbiAgICAvLyBFeGVjdXRlIGhvb2tzXG4gICAgaWYgKGZpZWxkLmhvb2tzPy5hZnRlclJlYWQpIHtcbiAgICAgIGF3YWl0IGZpZWxkLmhvb2tzLmFmdGVyUmVhZC5yZWR1Y2UoYXN5bmMgKHByaW9ySG9vaywgY3VycmVudEhvb2spID0+IHtcbiAgICAgICAgYXdhaXQgcHJpb3JIb29rXG5cbiAgICAgICAgY29uc3Qgc2hvdWxkUnVuSG9va09uQWxsTG9jYWxlcyA9XG4gICAgICAgICAgZmllbGQubG9jYWxpemVkICYmXG4gICAgICAgICAgKHJlcS5sb2NhbGUgPT09ICdhbGwnIHx8ICFmbGF0dGVuTG9jYWxlcykgJiZcbiAgICAgICAgICB0eXBlb2Ygc2libGluZ0RvY1tmaWVsZC5uYW1lXSA9PT0gJ29iamVjdCdcblxuICAgICAgICBpZiAoc2hvdWxkUnVuSG9va09uQWxsTG9jYWxlcykge1xuICAgICAgICAgIGNvbnN0IGhvb2tQcm9taXNlcyA9IE9iamVjdC5lbnRyaWVzKHNpYmxpbmdEb2NbZmllbGQubmFtZV0pLm1hcCgoW2xvY2FsZSwgdmFsdWVdKSA9PlxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgaG9va2VkVmFsdWUgPSBhd2FpdCBjdXJyZW50SG9vayh7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGRhdGE6IGRvYyxcbiAgICAgICAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICAgICAgICBnbG9iYWwsXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiAncmVhZCcsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxEb2M6IGRvYyxcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgc2libGluZ0RhdGE6IHNpYmxpbmdEb2MsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgaWYgKGhvb2tlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzaWJsaW5nRG9jW2ZpZWxkLm5hbWVdW2xvY2FsZV0gPSBob29rZWRWYWx1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpLFxuICAgICAgICAgIClcblxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGhvb2tQcm9taXNlcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBob29rZWRWYWx1ZSA9IGF3YWl0IGN1cnJlbnRIb29rKHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgZGF0YTogZG9jLFxuICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICBmaW5kTWFueSxcbiAgICAgICAgICAgIGdsb2JhbCxcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ3JlYWQnLFxuICAgICAgICAgICAgb3JpZ2luYWxEb2M6IGRvYyxcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIHNpYmxpbmdEYXRhOiBzaWJsaW5nRG9jLFxuICAgICAgICAgICAgdmFsdWU6IHNpYmxpbmdEb2NbZmllbGQubmFtZV0sXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGlmIChob29rZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzaWJsaW5nRG9jW2ZpZWxkLm5hbWVdID0gaG9va2VkVmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIFByb21pc2UucmVzb2x2ZSgpKVxuICAgIH1cblxuICAgIC8vIEV4ZWN1dGUgYWNjZXNzIGNvbnRyb2xcbiAgICBpZiAoZmllbGQuYWNjZXNzICYmIGZpZWxkLmFjY2Vzcy5yZWFkKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBvdmVycmlkZUFjY2Vzc1xuICAgICAgICA/IHRydWVcbiAgICAgICAgOiBhd2FpdCBmaWVsZC5hY2Nlc3MucmVhZCh7XG4gICAgICAgICAgICBpZDogZG9jLmlkIGFzIG51bWJlciB8IHN0cmluZyxcbiAgICAgICAgICAgIGRhdGE6IGRvYyxcbiAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIHNpYmxpbmdEYXRhOiBzaWJsaW5nRG9jLFxuICAgICAgICAgIH0pXG5cbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGRlbGV0ZSBzaWJsaW5nRG9jW2ZpZWxkLm5hbWVdXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZpZWxkLnR5cGUgPT09ICdyZWxhdGlvbnNoaXAnIHx8IGZpZWxkLnR5cGUgPT09ICd1cGxvYWQnKSB7XG4gICAgICBwb3B1bGF0aW9uUHJvbWlzZXMucHVzaChcbiAgICAgICAgcmVsYXRpb25zaGlwUG9wdWxhdGlvblByb21pc2Uoe1xuICAgICAgICAgIGN1cnJlbnREZXB0aCxcbiAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICBvdmVycmlkZUFjY2VzcyxcbiAgICAgICAgICByZXEsXG4gICAgICAgICAgc2hvd0hpZGRlbkZpZWxkcyxcbiAgICAgICAgICBzaWJsaW5nRG9jLFxuICAgICAgICB9KSxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICBjYXNlICdncm91cCc6IHtcbiAgICAgIGxldCBncm91cERvYyA9IHNpYmxpbmdEb2NbZmllbGQubmFtZV0gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICAgIGlmICh0eXBlb2Ygc2libGluZ0RvY1tmaWVsZC5uYW1lXSAhPT0gJ29iamVjdCcpIGdyb3VwRG9jID0ge31cblxuICAgICAgdHJhdmVyc2VGaWVsZHMoe1xuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjdXJyZW50RGVwdGgsXG4gICAgICAgIGRlcHRoLFxuICAgICAgICBkb2MsXG4gICAgICAgIGZpZWxkUHJvbWlzZXMsXG4gICAgICAgIGZpZWxkczogZmllbGQuZmllbGRzLFxuICAgICAgICBmaW5kTWFueSxcbiAgICAgICAgZmxhdHRlbkxvY2FsZXMsXG4gICAgICAgIGdsb2JhbCxcbiAgICAgICAgb3ZlcnJpZGVBY2Nlc3MsXG4gICAgICAgIHBvcHVsYXRpb25Qcm9taXNlcyxcbiAgICAgICAgcmVxLFxuICAgICAgICBzaG93SGlkZGVuRmllbGRzLFxuICAgICAgICBzaWJsaW5nRG9jOiBncm91cERvYyxcbiAgICAgIH0pXG5cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgY2FzZSAnYXJyYXknOiB7XG4gICAgICBjb25zdCByb3dzID0gc2libGluZ0RvY1tmaWVsZC5uYW1lXVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyb3dzKSkge1xuICAgICAgICByb3dzLmZvckVhY2goKHJvdykgPT4ge1xuICAgICAgICAgIHRyYXZlcnNlRmllbGRzKHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgY3VycmVudERlcHRoLFxuICAgICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICBmaWVsZFByb21pc2VzLFxuICAgICAgICAgICAgZmllbGRzOiBmaWVsZC5maWVsZHMsXG4gICAgICAgICAgICBmaW5kTWFueSxcbiAgICAgICAgICAgIGZsYXR0ZW5Mb2NhbGVzLFxuICAgICAgICAgICAgZ2xvYmFsLFxuICAgICAgICAgICAgb3ZlcnJpZGVBY2Nlc3MsXG4gICAgICAgICAgICBwb3B1bGF0aW9uUHJvbWlzZXMsXG4gICAgICAgICAgICByZXEsXG4gICAgICAgICAgICBzaG93SGlkZGVuRmllbGRzLFxuICAgICAgICAgICAgc2libGluZ0RvYzogcm93IHx8IHt9LFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKCFzaG91bGRIb2lzdExvY2FsaXplZFZhbHVlICYmIHR5cGVvZiByb3dzID09PSAnb2JqZWN0JyAmJiByb3dzICE9PSBudWxsKSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMocm93cykuZm9yRWFjaCgobG9jYWxlUm93cykgPT4ge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxvY2FsZVJvd3MpKSB7XG4gICAgICAgICAgICBsb2NhbGVSb3dzLmZvckVhY2goKHJvdykgPT4ge1xuICAgICAgICAgICAgICB0cmF2ZXJzZUZpZWxkcyh7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGN1cnJlbnREZXB0aCxcbiAgICAgICAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICAgICAgZmllbGRQcm9taXNlcyxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IGZpZWxkLmZpZWxkcyxcbiAgICAgICAgICAgICAgICBmaW5kTWFueSxcbiAgICAgICAgICAgICAgICBmbGF0dGVuTG9jYWxlcyxcbiAgICAgICAgICAgICAgICBnbG9iYWwsXG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVBY2Nlc3MsXG4gICAgICAgICAgICAgICAgcG9wdWxhdGlvblByb21pc2VzLFxuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICBzaG93SGlkZGVuRmllbGRzLFxuICAgICAgICAgICAgICAgIHNpYmxpbmdEb2M6IHJvdyB8fCB7fSxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2libGluZ0RvY1tmaWVsZC5uYW1lXSA9IFtdXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGNhc2UgJ2Jsb2Nrcyc6IHtcbiAgICAgIGNvbnN0IHJvd3MgPSBzaWJsaW5nRG9jW2ZpZWxkLm5hbWVdXG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvd3MpKSB7XG4gICAgICAgIHJvd3MuZm9yRWFjaCgocm93KSA9PiB7XG4gICAgICAgICAgY29uc3QgYmxvY2sgPSBmaWVsZC5ibG9ja3MuZmluZCgoYmxvY2tUeXBlKSA9PiBibG9ja1R5cGUuc2x1ZyA9PT0gcm93LmJsb2NrVHlwZSlcblxuICAgICAgICAgIGlmIChibG9jaykge1xuICAgICAgICAgICAgdHJhdmVyc2VGaWVsZHMoe1xuICAgICAgICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICBjdXJyZW50RGVwdGgsXG4gICAgICAgICAgICAgIGRlcHRoLFxuICAgICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICAgIGZpZWxkUHJvbWlzZXMsXG4gICAgICAgICAgICAgIGZpZWxkczogYmxvY2suZmllbGRzLFxuICAgICAgICAgICAgICBmaW5kTWFueSxcbiAgICAgICAgICAgICAgZmxhdHRlbkxvY2FsZXMsXG4gICAgICAgICAgICAgIGdsb2JhbCxcbiAgICAgICAgICAgICAgb3ZlcnJpZGVBY2Nlc3MsXG4gICAgICAgICAgICAgIHBvcHVsYXRpb25Qcm9taXNlcyxcbiAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICBzaG93SGlkZGVuRmllbGRzLFxuICAgICAgICAgICAgICBzaWJsaW5nRG9jOiByb3cgfHwge30sXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoIXNob3VsZEhvaXN0TG9jYWxpemVkVmFsdWUgJiYgdHlwZW9mIHJvd3MgPT09ICdvYmplY3QnICYmIHJvd3MgIT09IG51bGwpIHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhyb3dzKS5mb3JFYWNoKChsb2NhbGVSb3dzKSA9PiB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobG9jYWxlUm93cykpIHtcbiAgICAgICAgICAgIGxvY2FsZVJvd3MuZm9yRWFjaCgocm93KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gZmllbGQuYmxvY2tzLmZpbmQoKGJsb2NrVHlwZSkgPT4gYmxvY2tUeXBlLnNsdWcgPT09IHJvdy5ibG9ja1R5cGUpXG5cbiAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdHJhdmVyc2VGaWVsZHMoe1xuICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50RGVwdGgsXG4gICAgICAgICAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgICAgICAgIGZpZWxkUHJvbWlzZXMsXG4gICAgICAgICAgICAgICAgICBmaWVsZHM6IGJsb2NrLmZpZWxkcyxcbiAgICAgICAgICAgICAgICAgIGZpbmRNYW55LFxuICAgICAgICAgICAgICAgICAgZmxhdHRlbkxvY2FsZXMsXG4gICAgICAgICAgICAgICAgICBnbG9iYWwsXG4gICAgICAgICAgICAgICAgICBvdmVycmlkZUFjY2VzcyxcbiAgICAgICAgICAgICAgICAgIHBvcHVsYXRpb25Qcm9taXNlcyxcbiAgICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICAgIHNob3dIaWRkZW5GaWVsZHMsXG4gICAgICAgICAgICAgICAgICBzaWJsaW5nRG9jOiByb3cgfHwge30sXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWJsaW5nRG9jW2ZpZWxkLm5hbWVdID0gW11cbiAgICAgIH1cblxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBjYXNlICdyb3cnOlxuICAgIGNhc2UgJ2NvbGxhcHNpYmxlJzoge1xuICAgICAgdHJhdmVyc2VGaWVsZHMoe1xuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjdXJyZW50RGVwdGgsXG4gICAgICAgIGRlcHRoLFxuICAgICAgICBkb2MsXG4gICAgICAgIGZpZWxkUHJvbWlzZXMsXG4gICAgICAgIGZpZWxkczogZmllbGQuZmllbGRzLFxuICAgICAgICBmaW5kTWFueSxcbiAgICAgICAgZmxhdHRlbkxvY2FsZXMsXG4gICAgICAgIGdsb2JhbCxcbiAgICAgICAgb3ZlcnJpZGVBY2Nlc3MsXG4gICAgICAgIHBvcHVsYXRpb25Qcm9taXNlcyxcbiAgICAgICAgcmVxLFxuICAgICAgICBzaG93SGlkZGVuRmllbGRzLFxuICAgICAgICBzaWJsaW5nRG9jLFxuICAgICAgfSlcblxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBjYXNlICd0YWInOiB7XG4gICAgICBsZXQgdGFiRG9jID0gc2libGluZ0RvY1xuICAgICAgaWYgKHRhYkhhc05hbWUoZmllbGQpKSB7XG4gICAgICAgIHRhYkRvYyA9IHNpYmxpbmdEb2NbZmllbGQubmFtZV0gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICAgICAgaWYgKHR5cGVvZiBzaWJsaW5nRG9jW2ZpZWxkLm5hbWVdICE9PSAnb2JqZWN0JykgdGFiRG9jID0ge31cbiAgICAgIH1cblxuICAgICAgYXdhaXQgdHJhdmVyc2VGaWVsZHMoe1xuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjdXJyZW50RGVwdGgsXG4gICAgICAgIGRlcHRoLFxuICAgICAgICBkb2MsXG4gICAgICAgIGZpZWxkUHJvbWlzZXMsXG4gICAgICAgIGZpZWxkczogZmllbGQuZmllbGRzLFxuICAgICAgICBmaW5kTWFueSxcbiAgICAgICAgZmxhdHRlbkxvY2FsZXMsXG4gICAgICAgIGdsb2JhbCxcbiAgICAgICAgb3ZlcnJpZGVBY2Nlc3MsXG4gICAgICAgIHBvcHVsYXRpb25Qcm9taXNlcyxcbiAgICAgICAgcmVxLFxuICAgICAgICBzaG93SGlkZGVuRmllbGRzLFxuICAgICAgICBzaWJsaW5nRG9jOiB0YWJEb2MsXG4gICAgICB9KVxuXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGNhc2UgJ3RhYnMnOiB7XG4gICAgICB0cmF2ZXJzZUZpZWxkcyh7XG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGN1cnJlbnREZXB0aCxcbiAgICAgICAgZGVwdGgsXG4gICAgICAgIGRvYyxcbiAgICAgICAgZmllbGRQcm9taXNlcyxcbiAgICAgICAgZmllbGRzOiBmaWVsZC50YWJzLm1hcCgodGFiKSA9PiAoeyAuLi50YWIsIHR5cGU6ICd0YWInIH0pKSxcbiAgICAgICAgZmluZE1hbnksXG4gICAgICAgIGZsYXR0ZW5Mb2NhbGVzLFxuICAgICAgICBnbG9iYWwsXG4gICAgICAgIG92ZXJyaWRlQWNjZXNzLFxuICAgICAgICBwb3B1bGF0aW9uUHJvbWlzZXMsXG4gICAgICAgIHJlcSxcbiAgICAgICAgc2hvd0hpZGRlbkZpZWxkcyxcbiAgICAgICAgc2libGluZ0RvYyxcbiAgICAgIH0pXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsicHJvbWlzZSIsImNvbGxlY3Rpb24iLCJjb250ZXh0IiwiY3VycmVudERlcHRoIiwiZGVwdGgiLCJkb2MiLCJmaWVsZCIsImZpZWxkUHJvbWlzZXMiLCJmaW5kTWFueSIsImZsYXR0ZW5Mb2NhbGVzIiwiZ2xvYmFsIiwib3ZlcnJpZGVBY2Nlc3MiLCJwb3B1bGF0aW9uUHJvbWlzZXMiLCJyZXEiLCJzaG93SGlkZGVuRmllbGRzIiwic2libGluZ0RvYyIsImZpZWxkQWZmZWN0c0RhdGEiLCJoaWRkZW4iLCJuYW1lIiwic2hvdWxkSG9pc3RMb2NhbGl6ZWRWYWx1ZSIsImxvY2FsaXplZCIsImxvY2FsZSIsInBheWxvYWQiLCJjb25maWciLCJsb2NhbGl6YXRpb24iLCJ2YWx1ZSIsImZhbGxiYWNrTG9jYWxlIiwiZmFsbGJhY2siLCJob2lzdGVkVmFsdWUiLCJmYWxsYmFja1ZhbHVlIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJ0eXBlIiwidGFicyIsImZvckVhY2giLCJ0YWIiLCJ0YWJIYXNOYW1lIiwiZWRpdG9yIiwicG9wdWxhdGlvblByb21pc2UiLCJwdXNoIiwiYWZ0ZXJSZWFkUHJvbWlzZSIsImluY29taW5nRWRpdG9yU3RhdGUiLCJwb2ludERvYyIsIkFycmF5IiwiaXNBcnJheSIsImNvb3JkaW5hdGVzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiaG9va3MiLCJhZnRlclJlYWQiLCJyZWR1Y2UiLCJwcmlvckhvb2siLCJjdXJyZW50SG9vayIsInNob3VsZFJ1bkhvb2tPbkFsbExvY2FsZXMiLCJob29rUHJvbWlzZXMiLCJPYmplY3QiLCJlbnRyaWVzIiwibWFwIiwiaG9va2VkVmFsdWUiLCJkYXRhIiwib3BlcmF0aW9uIiwib3JpZ2luYWxEb2MiLCJzaWJsaW5nRGF0YSIsIlByb21pc2UiLCJhbGwiLCJyZXNvbHZlIiwiYWNjZXNzIiwicmVhZCIsInJlc3VsdCIsImlkIiwicmVsYXRpb25zaGlwUG9wdWxhdGlvblByb21pc2UiLCJncm91cERvYyIsInRyYXZlcnNlRmllbGRzIiwiZmllbGRzIiwicm93cyIsInJvdyIsInZhbHVlcyIsImxvY2FsZVJvd3MiLCJibG9jayIsImJsb2NrcyIsImZpbmQiLCJibG9ja1R5cGUiLCJzbHVnIiwidGFiRG9jIl0sIm1hcHBpbmdzIjoiQUFBQSxvQ0FBb0M7Ozs7K0JBcUN2QkE7OztlQUFBQTs7O3VCQTlCZ0M7c0ZBQ0g7Z0NBQ1g7Ozs7OztBQTRCeEIsTUFBTUEsVUFBVSxPQUFPLEVBQzVCQyxVQUFVLEVBQ1ZDLE9BQU8sRUFDUEMsWUFBWSxFQUNaQyxLQUFLLEVBQ0xDLEdBQUcsRUFDSEMsS0FBSyxFQUNMQyxhQUFhLEVBQ2JDLFFBQVEsRUFDUkMsY0FBYyxFQUNkQyxNQUFNLEVBQ05DLGNBQWMsRUFDZEMsa0JBQWtCLEVBQ2xCQyxHQUFHLEVBQ0hDLGdCQUFnQixFQUNoQkMsVUFBVSxFQUNMO0lBQ0wsSUFDRUMsSUFBQUEsdUJBQWdCLEVBQUNWLFVBQ2pCQSxNQUFNVyxNQUFNLElBQ1osT0FBT0YsVUFBVSxDQUFDVCxNQUFNWSxJQUFJLENBQUMsS0FBSyxlQUNsQyxDQUFDSixrQkFDRDtRQUNBLE9B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