/* eslint-disable no-param-reassign */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "promise", {
    enumerable: true,
    get: function() {
        return promise;
    }
});
const _deepmerge = /*#__PURE__*/ _interop_require_default(require("deepmerge"));
const _types = require("../../config/types");
const _getExistingRowDoc = require("./getExistingRowDoc");
const _traverseFields = require("./traverseFields");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const promise = async ({ id, collection, context, data, doc, docWithLocales, errors, field, global, mergeLocaleActions, operation, path, req, siblingData, siblingDoc, siblingDocWithLocales, skipValidation })=>{
    const passesCondition = field.admin?.condition ? field.admin.condition(data, siblingData, {
        user: req.user
    }) : true;
    let skipValidationFromHere = skipValidation || !passesCondition;
    const defaultLocale = req.payload.config?.localization ? req.payload.config.localization?.defaultLocale : 'en';
    const operationLocale = req.locale || defaultLocale;
    if ((0, _types.fieldAffectsData)(field)) {
        // skip validation if the field is localized and the incoming data is null
        if (field.localized && operationLocale !== defaultLocale) {
            if ([
                'array',
                'blocks'
            ].includes(field.type) && siblingData[field.name] === null) {
                skipValidationFromHere = true;
            }
        }
        // Execute hooks
        if (field.hooks?.beforeChange) {
            await field.hooks.beforeChange.reduce(async (priorHook, currentHook)=>{
                await priorHook;
                const hookedValue = await currentHook({
                    collection,
                    context,
                    data,
                    field,
                    global,
                    operation,
                    originalDoc: doc,
                    req,
                    siblingData,
                    value: siblingData[field.name]
                });
                if (hookedValue !== undefined) {
                    siblingData[field.name] = hookedValue;
                }
            }, Promise.resolve());
        }
        // Validate
        if (!skipValidationFromHere && field.validate) {
            const valueToValidate = siblingData[field.name];
            let jsonError;
            if (field.type === 'json' && typeof siblingData[field.name] === 'string') {
                try {
                    JSON.parse(siblingData[field.name]);
                } catch (e) {
                    jsonError = e;
                }
            }
            const validationResult = await field.validate(valueToValidate, {
                ...field,
                id,
                config: req.payload.config,
                data: (0, _deepmerge.default)(doc, data, {
                    arrayMerge: (_, source)=>source
                }),
                jsonError,
                operation,
                payload: req.payload,
                siblingData: (0, _deepmerge.default)(siblingDoc, siblingData, {
                    arrayMerge: (_, source)=>source
                }),
                t: req.t,
                user: req.user
            });
            if (typeof validationResult === 'string') {
                errors.push({
                    field: `${path}${field.name}`,
                    message: validationResult
                });
            }
        }
        // Push merge locale action if applicable
        if (field.localized) {
            mergeLocaleActions.push(()=>{
                if (req.payload.config.localization) {
                    const { localization } = req.payload.config;
                    const localeData = localization.localeCodes.reduce((localizedValues, locale)=>{
                        const fieldValue = locale === req.locale ? siblingData[field.name] : siblingDocWithLocales?.[field.name]?.[locale];
                        // update locale value if it's not undefined
                        if (typeof fieldValue !== 'undefined') {
                            return {
                                ...localizedValues,
                                [locale]: fieldValue
                            };
                        }
                        return localizedValues;
                    }, {});
                    // If there are locales with data, set the data
                    if (Object.keys(localeData).length > 0) {
                        siblingData[field.name] = localeData;
                    }
                }
            });
        }
    }
    switch(field.type){
        case 'point':
            {
                // Transform point data for storage
                if (Array.isArray(siblingData[field.name]) && siblingData[field.name][0] !== null && siblingData[field.name][1] !== null) {
                    siblingData[field.name] = {
                        coordinates: [
                            parseFloat(siblingData[field.name][0]),
                            parseFloat(siblingData[field.name][1])
                        ],
                        type: 'Point'
                    };
                }
                break;
            }
        case 'group':
            {
                if (typeof siblingData[field.name] !== 'object') siblingData[field.name] = {};
                if (typeof siblingDoc[field.name] !== 'object') siblingDoc[field.name] = {};
                if (typeof siblingDocWithLocales[field.name] !== 'object') siblingDocWithLocales[field.name] = {};
                await (0, _traverseFields.traverseFields)({
                    id,
                    collection,
                    context,
                    data,
                    doc,
                    docWithLocales,
                    errors,
                    fields: field.fields,
                    global,
                    mergeLocaleActions,
                    operation,
                    path: `${path}${field.name}.`,
                    req,
                    siblingData: siblingData[field.name],
                    siblingDoc: siblingDoc[field.name],
                    siblingDocWithLocales: siblingDocWithLocales[field.name],
                    skipValidation: skipValidationFromHere
                });
                break;
            }
        case 'array':
            {
                const rows = siblingData[field.name];
                if (Array.isArray(rows)) {
                    const promises = [];
                    rows.forEach((row, i)=>{
                        promises.push((0, _traverseFields.traverseFields)({
                            id,
                            collection,
                            context,
                            data,
                            doc,
                            docWithLocales,
                            errors,
                            fields: field.fields,
                            global,
                            mergeLocaleActions,
                            operation,
                            path: `${path}${field.name}.${i}.`,
                            req,
                            siblingData: row,
                            siblingDoc: (0, _getExistingRowDoc.getExistingRowDoc)(row, siblingDoc[field.name]),
                            siblingDocWithLocales: (0, _getExistingRowDoc.getExistingRowDoc)(row, siblingDocWithLocales[field.name]),
                            skipValidation: skipValidationFromHere
                        }));
                    });
                    await Promise.all(promises);
                }
                break;
            }
        case 'blocks':
            {
                const rows = siblingData[field.name];
                if (Array.isArray(rows)) {
                    const promises = [];
                    rows.forEach((row, i)=>{
                        const rowSiblingDoc = (0, _getExistingRowDoc.getExistingRowDoc)(row, siblingDoc[field.name]);
                        const rowSiblingDocWithLocales = (0, _getExistingRowDoc.getExistingRowDoc)(row, siblingDocWithLocales[field.name]);
                        const blockTypeToMatch = row.blockType || rowSiblingDoc.blockType;
                        const block = field.blocks.find((blockType)=>blockType.slug === blockTypeToMatch);
                        if (block) {
                            promises.push((0, _traverseFields.traverseFields)({
                                id,
                                collection,
                                context,
                                data,
                                doc,
                                docWithLocales,
                                errors,
                                fields: block.fields,
                                global,
                                mergeLocaleActions,
                                operation,
                                path: `${path}${field.name}.${i}.`,
                                req,
                                siblingData: row,
                                siblingDoc: rowSiblingDoc,
                                siblingDocWithLocales: rowSiblingDocWithLocales,
                                skipValidation: skipValidationFromHere
                            }));
                        }
                    });
                    await Promise.all(promises);
                }
                break;
            }
        case 'row':
        case 'collapsible':
            {
                await (0, _traverseFields.traverseFields)({
                    id,
                    collection,
                    context,
                    data,
                    doc,
                    docWithLocales,
                    errors,
                    fields: field.fields,
                    global,
                    mergeLocaleActions,
                    operation,
                    path,
                    req,
                    siblingData,
                    siblingDoc,
                    siblingDocWithLocales,
                    skipValidation: skipValidationFromHere
                });
                break;
            }
        case 'tab':
            {
                let tabPath = path;
                let tabSiblingData = siblingData;
                let tabSiblingDoc = siblingDoc;
                let tabSiblingDocWithLocales = siblingDocWithLocales;
                if ((0, _types.tabHasName)(field)) {
                    tabPath = `${path}${field.name}.`;
                    if (typeof siblingData[field.name] !== 'object') siblingData[field.name] = {};
                    if (typeof siblingDoc[field.name] !== 'object') siblingDoc[field.name] = {};
                    if (typeof siblingDocWithLocales[field.name] !== 'object') siblingDocWithLocales[field.name] = {};
                    tabSiblingData = siblingData[field.name];
                    tabSiblingDoc = siblingDoc[field.name];
                    tabSiblingDocWithLocales = siblingDocWithLocales[field.name];
                }
                await (0, _traverseFields.traverseFields)({
                    id,
                    collection,
                    context,
                    data,
                    doc,
                    docWithLocales,
                    errors,
                    fields: field.fields,
                    global,
                    mergeLocaleActions,
                    operation,
                    path: tabPath,
                    req,
                    siblingData: tabSiblingData,
                    siblingDoc: tabSiblingDoc,
                    siblingDocWithLocales: tabSiblingDocWithLocales,
                    skipValidation: skipValidationFromHere
                });
                break;
            }
        case 'tabs':
            {
                await (0, _traverseFields.traverseFields)({
                    id,
                    collection,
                    context,
                    data,
                    doc,
                    docWithLocales,
                    errors,
                    fields: field.tabs.map((tab)=>({
                            ...tab,
                            type: 'tab'
                        })),
                    global,
                    mergeLocaleActions,
                    operation,
                    path,
                    req,
                    siblingData,
                    siblingDoc,
                    siblingDocWithLocales,
                    skipValidation: skipValidationFromHere
                });
                break;
            }
        default:
            {
                break;
            }
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9maWVsZHMvaG9va3MvYmVmb3JlQ2hhbmdlL3Byb21pc2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbmltcG9ydCBtZXJnZSBmcm9tICdkZWVwbWVyZ2UnXG5cbmltcG9ydCB0eXBlIHsgU2FuaXRpemVkQ29sbGVjdGlvbkNvbmZpZyB9IGZyb20gJy4uLy4uLy4uL2NvbGxlY3Rpb25zL2NvbmZpZy90eXBlcydcbmltcG9ydCB0eXBlIHsgUGF5bG9hZFJlcXVlc3QsIFJlcXVlc3RDb250ZXh0IH0gZnJvbSAnLi4vLi4vLi4vZXhwcmVzcy90eXBlcydcbmltcG9ydCB0eXBlIHsgU2FuaXRpemVkR2xvYmFsQ29uZmlnIH0gZnJvbSAnLi4vLi4vLi4vZ2xvYmFscy9jb25maWcvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IE9wZXJhdGlvbiB9IGZyb20gJy4uLy4uLy4uL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBGaWVsZCwgVGFiQXNGaWVsZCB9IGZyb20gJy4uLy4uL2NvbmZpZy90eXBlcydcblxuaW1wb3J0IHsgZmllbGRBZmZlY3RzRGF0YSwgdGFiSGFzTmFtZSB9IGZyb20gJy4uLy4uL2NvbmZpZy90eXBlcydcbmltcG9ydCB7IGdldEV4aXN0aW5nUm93RG9jIH0gZnJvbSAnLi9nZXRFeGlzdGluZ1Jvd0RvYydcbmltcG9ydCB7IHRyYXZlcnNlRmllbGRzIH0gZnJvbSAnLi90cmF2ZXJzZUZpZWxkcydcblxudHlwZSBBcmdzID0ge1xuICBjb2xsZWN0aW9uOiBTYW5pdGl6ZWRDb2xsZWN0aW9uQ29uZmlnIHwgbnVsbFxuICBjb250ZXh0OiBSZXF1ZXN0Q29udGV4dFxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICBkb2M6IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gIGRvY1dpdGhMb2NhbGVzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICBlcnJvcnM6IHsgZmllbGQ6IHN0cmluZzsgbWVzc2FnZTogc3RyaW5nIH1bXVxuICBmaWVsZDogRmllbGQgfCBUYWJBc0ZpZWxkXG4gIGdsb2JhbDogU2FuaXRpemVkR2xvYmFsQ29uZmlnIHwgbnVsbFxuICBpZD86IG51bWJlciB8IHN0cmluZ1xuICBtZXJnZUxvY2FsZUFjdGlvbnM6ICgoKSA9PiB2b2lkKVtdXG4gIG9wZXJhdGlvbjogT3BlcmF0aW9uXG4gIHBhdGg6IHN0cmluZ1xuICByZXE6IFBheWxvYWRSZXF1ZXN0XG4gIHNpYmxpbmdEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICBzaWJsaW5nRG9jOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICBzaWJsaW5nRG9jV2l0aExvY2FsZXM/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICBza2lwVmFsaWRhdGlvbjogYm9vbGVhblxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgZm9sbG93aW5nIGFjdGlvbnMsIGluIG9yZGVyOlxuLy8gLSBSdW4gY29uZGl0aW9uXG4vLyAtIEV4ZWN1dGUgZmllbGQgaG9va3Ncbi8vIC0gVmFsaWRhdGUgZGF0YVxuLy8gLSBUcmFuc2Zvcm0gZGF0YSBmb3Igc3RvcmFnZVxuLy8gLSBVbmZsYXR0ZW4gbG9jYWxlc1xuXG5leHBvcnQgY29uc3QgcHJvbWlzZSA9IGFzeW5jICh7XG4gIGlkLFxuICBjb2xsZWN0aW9uLFxuICBjb250ZXh0LFxuICBkYXRhLFxuICBkb2MsXG4gIGRvY1dpdGhMb2NhbGVzLFxuICBlcnJvcnMsXG4gIGZpZWxkLFxuICBnbG9iYWwsXG4gIG1lcmdlTG9jYWxlQWN0aW9ucyxcbiAgb3BlcmF0aW9uLFxuICBwYXRoLFxuICByZXEsXG4gIHNpYmxpbmdEYXRhLFxuICBzaWJsaW5nRG9jLFxuICBzaWJsaW5nRG9jV2l0aExvY2FsZXMsXG4gIHNraXBWYWxpZGF0aW9uLFxufTogQXJncyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBjb25zdCBwYXNzZXNDb25kaXRpb24gPSBmaWVsZC5hZG1pbj8uY29uZGl0aW9uXG4gICAgPyBmaWVsZC5hZG1pbi5jb25kaXRpb24oZGF0YSwgc2libGluZ0RhdGEsIHsgdXNlcjogcmVxLnVzZXIgfSlcbiAgICA6IHRydWVcbiAgbGV0IHNraXBWYWxpZGF0aW9uRnJvbUhlcmUgPSBza2lwVmFsaWRhdGlvbiB8fCAhcGFzc2VzQ29uZGl0aW9uXG5cbiAgY29uc3QgZGVmYXVsdExvY2FsZSA9IHJlcS5wYXlsb2FkLmNvbmZpZz8ubG9jYWxpemF0aW9uXG4gICAgPyByZXEucGF5bG9hZC5jb25maWcubG9jYWxpemF0aW9uPy5kZWZhdWx0TG9jYWxlXG4gICAgOiAnZW4nXG4gIGNvbnN0IG9wZXJhdGlvbkxvY2FsZSA9IHJlcS5sb2NhbGUgfHwgZGVmYXVsdExvY2FsZVxuXG4gIGlmIChmaWVsZEFmZmVjdHNEYXRhKGZpZWxkKSkge1xuICAgIC8vIHNraXAgdmFsaWRhdGlvbiBpZiB0aGUgZmllbGQgaXMgbG9jYWxpemVkIGFuZCB0aGUgaW5jb21pbmcgZGF0YSBpcyBudWxsXG4gICAgaWYgKGZpZWxkLmxvY2FsaXplZCAmJiBvcGVyYXRpb25Mb2NhbGUgIT09IGRlZmF1bHRMb2NhbGUpIHtcbiAgICAgIGlmIChbJ2FycmF5JywgJ2Jsb2NrcyddLmluY2x1ZGVzKGZpZWxkLnR5cGUpICYmIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID09PSBudWxsKSB7XG4gICAgICAgIHNraXBWYWxpZGF0aW9uRnJvbUhlcmUgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhlY3V0ZSBob29rc1xuICAgIGlmIChmaWVsZC5ob29rcz8uYmVmb3JlQ2hhbmdlKSB7XG4gICAgICBhd2FpdCBmaWVsZC5ob29rcy5iZWZvcmVDaGFuZ2UucmVkdWNlKGFzeW5jIChwcmlvckhvb2ssIGN1cnJlbnRIb29rKSA9PiB7XG4gICAgICAgIGF3YWl0IHByaW9ySG9va1xuXG4gICAgICAgIGNvbnN0IGhvb2tlZFZhbHVlID0gYXdhaXQgY3VycmVudEhvb2soe1xuICAgICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGZpZWxkLFxuICAgICAgICAgIGdsb2JhbCxcbiAgICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgICAgb3JpZ2luYWxEb2M6IGRvYyxcbiAgICAgICAgICByZXEsXG4gICAgICAgICAgc2libGluZ0RhdGEsXG4gICAgICAgICAgdmFsdWU6IHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdLFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChob29rZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2libGluZ0RhdGFbZmllbGQubmFtZV0gPSBob29rZWRWYWx1ZVxuICAgICAgICB9XG4gICAgICB9LCBQcm9taXNlLnJlc29sdmUoKSlcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZVxuICAgIGlmICghc2tpcFZhbGlkYXRpb25Gcm9tSGVyZSAmJiBmaWVsZC52YWxpZGF0ZSkge1xuICAgICAgY29uc3QgdmFsdWVUb1ZhbGlkYXRlID0gc2libGluZ0RhdGFbZmllbGQubmFtZV1cbiAgICAgIGxldCBqc29uRXJyb3JcblxuICAgICAgaWYgKGZpZWxkLnR5cGUgPT09ICdqc29uJyAmJiB0eXBlb2Ygc2libGluZ0RhdGFbZmllbGQubmFtZV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgSlNPTi5wYXJzZShzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSBhcyBzdHJpbmcpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBqc29uRXJyb3IgPSBlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IGZpZWxkLnZhbGlkYXRlKHZhbHVlVG9WYWxpZGF0ZSwge1xuICAgICAgICAuLi5maWVsZCxcbiAgICAgICAgaWQsXG4gICAgICAgIGNvbmZpZzogcmVxLnBheWxvYWQuY29uZmlnLFxuICAgICAgICBkYXRhOiBtZXJnZShkb2MsIGRhdGEsIHsgYXJyYXlNZXJnZTogKF8sIHNvdXJjZSkgPT4gc291cmNlIH0pLFxuICAgICAgICBqc29uRXJyb3IsXG4gICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgcGF5bG9hZDogcmVxLnBheWxvYWQsXG4gICAgICAgIHNpYmxpbmdEYXRhOiBtZXJnZShzaWJsaW5nRG9jLCBzaWJsaW5nRGF0YSwgeyBhcnJheU1lcmdlOiAoXywgc291cmNlKSA9PiBzb3VyY2UgfSksXG4gICAgICAgIHQ6IHJlcS50LFxuICAgICAgICB1c2VyOiByZXEudXNlcixcbiAgICAgIH0pXG5cbiAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGlvblJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgIGZpZWxkOiBgJHtwYXRofSR7ZmllbGQubmFtZX1gLFxuICAgICAgICAgIG1lc3NhZ2U6IHZhbGlkYXRpb25SZXN1bHQsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHVzaCBtZXJnZSBsb2NhbGUgYWN0aW9uIGlmIGFwcGxpY2FibGVcbiAgICBpZiAoZmllbGQubG9jYWxpemVkKSB7XG4gICAgICBtZXJnZUxvY2FsZUFjdGlvbnMucHVzaCgoKSA9PiB7XG4gICAgICAgIGlmIChyZXEucGF5bG9hZC5jb25maWcubG9jYWxpemF0aW9uKSB7XG4gICAgICAgICAgY29uc3QgeyBsb2NhbGl6YXRpb24gfSA9IHJlcS5wYXlsb2FkLmNvbmZpZ1xuICAgICAgICAgIGNvbnN0IGxvY2FsZURhdGEgPSBsb2NhbGl6YXRpb24ubG9jYWxlQ29kZXMucmVkdWNlKChsb2NhbGl6ZWRWYWx1ZXMsIGxvY2FsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9XG4gICAgICAgICAgICAgIGxvY2FsZSA9PT0gcmVxLmxvY2FsZVxuICAgICAgICAgICAgICAgID8gc2libGluZ0RhdGFbZmllbGQubmFtZV1cbiAgICAgICAgICAgICAgICA6IHNpYmxpbmdEb2NXaXRoTG9jYWxlcz8uW2ZpZWxkLm5hbWVdPy5bbG9jYWxlXVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgbG9jYWxlIHZhbHVlIGlmIGl0J3Mgbm90IHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmxvY2FsaXplZFZhbHVlcyxcbiAgICAgICAgICAgICAgICBbbG9jYWxlXTogZmllbGRWYWx1ZSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxpemVkVmFsdWVzXG4gICAgICAgICAgfSwge30pXG5cbiAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbG9jYWxlcyB3aXRoIGRhdGEsIHNldCB0aGUgZGF0YVxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhsb2NhbGVEYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSA9IGxvY2FsZURhdGFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgY2FzZSAncG9pbnQnOiB7XG4gICAgICAvLyBUcmFuc2Zvcm0gcG9pbnQgZGF0YSBmb3Igc3RvcmFnZVxuICAgICAgaWYgKFxuICAgICAgICBBcnJheS5pc0FycmF5KHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdKSAmJlxuICAgICAgICBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXVswXSAhPT0gbnVsbCAmJlxuICAgICAgICBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXVsxXSAhPT0gbnVsbFxuICAgICAgKSB7XG4gICAgICAgIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID0ge1xuICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICBwYXJzZUZsb2F0KHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdWzBdKSxcbiAgICAgICAgICAgIHBhcnNlRmxvYXQoc2libGluZ0RhdGFbZmllbGQubmFtZV1bMV0pLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgdHlwZTogJ1BvaW50JyxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGNhc2UgJ2dyb3VwJzoge1xuICAgICAgaWYgKHR5cGVvZiBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSAhPT0gJ29iamVjdCcpIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID0ge31cbiAgICAgIGlmICh0eXBlb2Ygc2libGluZ0RvY1tmaWVsZC5uYW1lXSAhPT0gJ29iamVjdCcpIHNpYmxpbmdEb2NbZmllbGQubmFtZV0gPSB7fVxuICAgICAgaWYgKHR5cGVvZiBzaWJsaW5nRG9jV2l0aExvY2FsZXNbZmllbGQubmFtZV0gIT09ICdvYmplY3QnKVxuICAgICAgICBzaWJsaW5nRG9jV2l0aExvY2FsZXNbZmllbGQubmFtZV0gPSB7fVxuXG4gICAgICBhd2FpdCB0cmF2ZXJzZUZpZWxkcyh7XG4gICAgICAgIGlkLFxuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBkYXRhLFxuICAgICAgICBkb2MsXG4gICAgICAgIGRvY1dpdGhMb2NhbGVzLFxuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGZpZWxkczogZmllbGQuZmllbGRzLFxuICAgICAgICBnbG9iYWwsXG4gICAgICAgIG1lcmdlTG9jYWxlQWN0aW9ucyxcbiAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICBwYXRoOiBgJHtwYXRofSR7ZmllbGQubmFtZX0uYCxcbiAgICAgICAgcmVxLFxuICAgICAgICBzaWJsaW5nRGF0YTogc2libGluZ0RhdGFbZmllbGQubmFtZV0gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgICAgIHNpYmxpbmdEb2M6IHNpYmxpbmdEb2NbZmllbGQubmFtZV0gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgICAgIHNpYmxpbmdEb2NXaXRoTG9jYWxlczogc2libGluZ0RvY1dpdGhMb2NhbGVzW2ZpZWxkLm5hbWVdIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICAgICAgICBza2lwVmFsaWRhdGlvbjogc2tpcFZhbGlkYXRpb25Gcm9tSGVyZSxcbiAgICAgIH0pXG5cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgY2FzZSAnYXJyYXknOiB7XG4gICAgICBjb25zdCByb3dzID0gc2libGluZ0RhdGFbZmllbGQubmFtZV1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocm93cykpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXVxuICAgICAgICByb3dzLmZvckVhY2goKHJvdywgaSkgPT4ge1xuICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICB0cmF2ZXJzZUZpZWxkcyh7XG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICAgIGRvY1dpdGhMb2NhbGVzLFxuICAgICAgICAgICAgICBlcnJvcnMsXG4gICAgICAgICAgICAgIGZpZWxkczogZmllbGQuZmllbGRzLFxuICAgICAgICAgICAgICBnbG9iYWwsXG4gICAgICAgICAgICAgIG1lcmdlTG9jYWxlQWN0aW9ucyxcbiAgICAgICAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICAgICAgICBwYXRoOiBgJHtwYXRofSR7ZmllbGQubmFtZX0uJHtpfS5gLFxuICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgIHNpYmxpbmdEYXRhOiByb3csXG4gICAgICAgICAgICAgIHNpYmxpbmdEb2M6IGdldEV4aXN0aW5nUm93RG9jKHJvdywgc2libGluZ0RvY1tmaWVsZC5uYW1lXSksXG4gICAgICAgICAgICAgIHNpYmxpbmdEb2NXaXRoTG9jYWxlczogZ2V0RXhpc3RpbmdSb3dEb2Mocm93LCBzaWJsaW5nRG9jV2l0aExvY2FsZXNbZmllbGQubmFtZV0pLFxuICAgICAgICAgICAgICBza2lwVmFsaWRhdGlvbjogc2tpcFZhbGlkYXRpb25Gcm9tSGVyZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIClcbiAgICAgICAgfSlcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgICAgIH1cblxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBjYXNlICdibG9ja3MnOiB7XG4gICAgICBjb25zdCByb3dzID0gc2libGluZ0RhdGFbZmllbGQubmFtZV1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocm93cykpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXVxuICAgICAgICByb3dzLmZvckVhY2goKHJvdywgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJvd1NpYmxpbmdEb2MgPSBnZXRFeGlzdGluZ1Jvd0RvYyhyb3csIHNpYmxpbmdEb2NbZmllbGQubmFtZV0pXG4gICAgICAgICAgY29uc3Qgcm93U2libGluZ0RvY1dpdGhMb2NhbGVzID0gZ2V0RXhpc3RpbmdSb3dEb2Mocm93LCBzaWJsaW5nRG9jV2l0aExvY2FsZXNbZmllbGQubmFtZV0pXG5cbiAgICAgICAgICBjb25zdCBibG9ja1R5cGVUb01hdGNoID0gcm93LmJsb2NrVHlwZSB8fCByb3dTaWJsaW5nRG9jLmJsb2NrVHlwZVxuICAgICAgICAgIGNvbnN0IGJsb2NrID0gZmllbGQuYmxvY2tzLmZpbmQoKGJsb2NrVHlwZSkgPT4gYmxvY2tUeXBlLnNsdWcgPT09IGJsb2NrVHlwZVRvTWF0Y2gpXG5cbiAgICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIHRyYXZlcnNlRmllbGRzKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICAgICAgZG9jV2l0aExvY2FsZXMsXG4gICAgICAgICAgICAgICAgZXJyb3JzLFxuICAgICAgICAgICAgICAgIGZpZWxkczogYmxvY2suZmllbGRzLFxuICAgICAgICAgICAgICAgIGdsb2JhbCxcbiAgICAgICAgICAgICAgICBtZXJnZUxvY2FsZUFjdGlvbnMsXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIHBhdGg6IGAke3BhdGh9JHtmaWVsZC5uYW1lfS4ke2l9LmAsXG4gICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgIHNpYmxpbmdEYXRhOiByb3csXG4gICAgICAgICAgICAgICAgc2libGluZ0RvYzogcm93U2libGluZ0RvYyxcbiAgICAgICAgICAgICAgICBzaWJsaW5nRG9jV2l0aExvY2FsZXM6IHJvd1NpYmxpbmdEb2NXaXRoTG9jYWxlcyxcbiAgICAgICAgICAgICAgICBza2lwVmFsaWRhdGlvbjogc2tpcFZhbGlkYXRpb25Gcm9tSGVyZSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgfVxuXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGNhc2UgJ3Jvdyc6XG4gICAgY2FzZSAnY29sbGFwc2libGUnOiB7XG4gICAgICBhd2FpdCB0cmF2ZXJzZUZpZWxkcyh7XG4gICAgICAgIGlkLFxuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBkYXRhLFxuICAgICAgICBkb2MsXG4gICAgICAgIGRvY1dpdGhMb2NhbGVzLFxuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGZpZWxkczogZmllbGQuZmllbGRzLFxuICAgICAgICBnbG9iYWwsXG4gICAgICAgIG1lcmdlTG9jYWxlQWN0aW9ucyxcbiAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICBwYXRoLFxuICAgICAgICByZXEsXG4gICAgICAgIHNpYmxpbmdEYXRhLFxuICAgICAgICBzaWJsaW5nRG9jLFxuICAgICAgICBzaWJsaW5nRG9jV2l0aExvY2FsZXMsXG4gICAgICAgIHNraXBWYWxpZGF0aW9uOiBza2lwVmFsaWRhdGlvbkZyb21IZXJlLFxuICAgICAgfSlcblxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBjYXNlICd0YWInOiB7XG4gICAgICBsZXQgdGFiUGF0aCA9IHBhdGhcbiAgICAgIGxldCB0YWJTaWJsaW5nRGF0YSA9IHNpYmxpbmdEYXRhXG4gICAgICBsZXQgdGFiU2libGluZ0RvYyA9IHNpYmxpbmdEb2NcbiAgICAgIGxldCB0YWJTaWJsaW5nRG9jV2l0aExvY2FsZXMgPSBzaWJsaW5nRG9jV2l0aExvY2FsZXNcblxuICAgICAgaWYgKHRhYkhhc05hbWUoZmllbGQpKSB7XG4gICAgICAgIHRhYlBhdGggPSBgJHtwYXRofSR7ZmllbGQubmFtZX0uYFxuICAgICAgICBpZiAodHlwZW9mIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdICE9PSAnb2JqZWN0Jykgc2libGluZ0RhdGFbZmllbGQubmFtZV0gPSB7fVxuICAgICAgICBpZiAodHlwZW9mIHNpYmxpbmdEb2NbZmllbGQubmFtZV0gIT09ICdvYmplY3QnKSBzaWJsaW5nRG9jW2ZpZWxkLm5hbWVdID0ge31cbiAgICAgICAgaWYgKHR5cGVvZiBzaWJsaW5nRG9jV2l0aExvY2FsZXNbZmllbGQubmFtZV0gIT09ICdvYmplY3QnKVxuICAgICAgICAgIHNpYmxpbmdEb2NXaXRoTG9jYWxlc1tmaWVsZC5uYW1lXSA9IHt9XG5cbiAgICAgICAgdGFiU2libGluZ0RhdGEgPSBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICAgICAgICB0YWJTaWJsaW5nRG9jID0gc2libGluZ0RvY1tmaWVsZC5uYW1lXSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICAgICAgICB0YWJTaWJsaW5nRG9jV2l0aExvY2FsZXMgPSBzaWJsaW5nRG9jV2l0aExvY2FsZXNbZmllbGQubmFtZV0gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgICAgIH1cblxuICAgICAgYXdhaXQgdHJhdmVyc2VGaWVsZHMoe1xuICAgICAgICBpZCxcbiAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgZG9jLFxuICAgICAgICBkb2NXaXRoTG9jYWxlcyxcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBmaWVsZHM6IGZpZWxkLmZpZWxkcyxcbiAgICAgICAgZ2xvYmFsLFxuICAgICAgICBtZXJnZUxvY2FsZUFjdGlvbnMsXG4gICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgcGF0aDogdGFiUGF0aCxcbiAgICAgICAgcmVxLFxuICAgICAgICBzaWJsaW5nRGF0YTogdGFiU2libGluZ0RhdGEsXG4gICAgICAgIHNpYmxpbmdEb2M6IHRhYlNpYmxpbmdEb2MsXG4gICAgICAgIHNpYmxpbmdEb2NXaXRoTG9jYWxlczogdGFiU2libGluZ0RvY1dpdGhMb2NhbGVzLFxuICAgICAgICBza2lwVmFsaWRhdGlvbjogc2tpcFZhbGlkYXRpb25Gcm9tSGVyZSxcbiAgICAgIH0pXG5cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgY2FzZSAndGFicyc6IHtcbiAgICAgIGF3YWl0IHRyYXZlcnNlRmllbGRzKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGRvYyxcbiAgICAgICAgZG9jV2l0aExvY2FsZXMsXG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgZmllbGRzOiBmaWVsZC50YWJzLm1hcCgodGFiKSA9PiAoeyAuLi50YWIsIHR5cGU6ICd0YWInIH0pKSxcbiAgICAgICAgZ2xvYmFsLFxuICAgICAgICBtZXJnZUxvY2FsZUFjdGlvbnMsXG4gICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgcGF0aCxcbiAgICAgICAgcmVxLFxuICAgICAgICBzaWJsaW5nRGF0YSxcbiAgICAgICAgc2libGluZ0RvYyxcbiAgICAgICAgc2libGluZ0RvY1dpdGhMb2NhbGVzLFxuICAgICAgICBza2lwVmFsaWRhdGlvbjogc2tpcFZhbGlkYXRpb25Gcm9tSGVyZSxcbiAgICAgIH0pXG5cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJwcm9taXNlIiwiaWQiLCJjb2xsZWN0aW9uIiwiY29udGV4dCIsImRhdGEiLCJkb2MiLCJkb2NXaXRoTG9jYWxlcyIsImVycm9ycyIsImZpZWxkIiwiZ2xvYmFsIiwibWVyZ2VMb2NhbGVBY3Rpb25zIiwib3BlcmF0aW9uIiwicGF0aCIsInJlcSIsInNpYmxpbmdEYXRhIiwic2libGluZ0RvYyIsInNpYmxpbmdEb2NXaXRoTG9jYWxlcyIsInNraXBWYWxpZGF0aW9uIiwicGFzc2VzQ29uZGl0aW9uIiwiYWRtaW4iLCJjb25kaXRpb24iLCJ1c2VyIiwic2tpcFZhbGlkYXRpb25Gcm9tSGVyZSIsImRlZmF1bHRMb2NhbGUiLCJwYXlsb2FkIiwiY29uZmlnIiwibG9jYWxpemF0aW9uIiwib3BlcmF0aW9uTG9jYWxlIiwibG9jYWxlIiwiZmllbGRBZmZlY3RzRGF0YSIsImxvY2FsaXplZCIsImluY2x1ZGVzIiwidHlwZSIsIm5hbWUiLCJob29rcyIsImJlZm9yZUNoYW5nZSIsInJlZHVjZSIsInByaW9ySG9vayIsImN1cnJlbnRIb29rIiwiaG9va2VkVmFsdWUiLCJvcmlnaW5hbERvYyIsInZhbHVlIiwidW5kZWZpbmVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ2YWxpZGF0ZSIsInZhbHVlVG9WYWxpZGF0ZSIsImpzb25FcnJvciIsIkpTT04iLCJwYXJzZSIsImUiLCJ2YWxpZGF0aW9uUmVzdWx0IiwibWVyZ2UiLCJhcnJheU1lcmdlIiwiXyIsInNvdXJjZSIsInQiLCJwdXNoIiwibWVzc2FnZSIsImxvY2FsZURhdGEiLCJsb2NhbGVDb2RlcyIsImxvY2FsaXplZFZhbHVlcyIsImZpZWxkVmFsdWUiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwiY29vcmRpbmF0ZXMiLCJwYXJzZUZsb2F0IiwidHJhdmVyc2VGaWVsZHMiLCJmaWVsZHMiLCJyb3dzIiwicHJvbWlzZXMiLCJmb3JFYWNoIiwicm93IiwiaSIsImdldEV4aXN0aW5nUm93RG9jIiwiYWxsIiwicm93U2libGluZ0RvYyIsInJvd1NpYmxpbmdEb2NXaXRoTG9jYWxlcyIsImJsb2NrVHlwZVRvTWF0Y2giLCJibG9ja1R5cGUiLCJibG9jayIsImJsb2NrcyIsImZpbmQiLCJzbHVnIiwidGFiUGF0aCIsInRhYlNpYmxpbmdEYXRhIiwidGFiU2libGluZ0RvYyIsInRhYlNpYmxpbmdEb2NXaXRoTG9jYWxlcyIsInRhYkhhc05hbWUiLCJ0YWJzIiwibWFwIiwidGFiIl0sIm1hcHBpbmdzIjoiQUFBQSxvQ0FBb0M7Ozs7K0JBd0N2QkE7OztlQUFBQTs7O2tFQXZDSzt1QkFRMkI7bUNBQ1g7Z0NBQ0g7Ozs7OztBQTZCeEIsTUFBTUEsVUFBVSxPQUFPLEVBQzVCQyxFQUFFLEVBQ0ZDLFVBQVUsRUFDVkMsT0FBTyxFQUNQQyxJQUFJLEVBQ0pDLEdBQUcsRUFDSEMsY0FBYyxFQUNkQyxNQUFNLEVBQ05DLEtBQUssRUFDTEMsTUFBTSxFQUNOQyxrQkFBa0IsRUFDbEJDLFNBQVMsRUFDVEMsSUFBSSxFQUNKQyxHQUFHLEVBQ0hDLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyxxQkFBcUIsRUFDckJDLGNBQWMsRUFDVDtJQUNMLE1BQU1DLGtCQUFrQlYsTUFBTVcsS0FBSyxFQUFFQyxZQUNqQ1osTUFB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