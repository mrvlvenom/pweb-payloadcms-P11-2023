"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "generateFileData", {
    enumerable: true,
    get: function() {
        return generateFileData;
    }
});
const _filetype = require("file-type");
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _mkdirp = /*#__PURE__*/ _interop_require_default(require("mkdirp"));
const _path = /*#__PURE__*/ _interop_require_default(require("path"));
const _sanitizefilename = /*#__PURE__*/ _interop_require_default(require("sanitize-filename"));
const _sharp = /*#__PURE__*/ _interop_require_default(require("sharp"));
const _errors = require("../errors");
const _canResizeImage = /*#__PURE__*/ _interop_require_default(require("./canResizeImage"));
const _cropImage = /*#__PURE__*/ _interop_require_default(require("./cropImage"));
const _getFileByPath = /*#__PURE__*/ _interop_require_default(require("./getFileByPath"));
const _getImageSize = /*#__PURE__*/ _interop_require_default(require("./getImageSize"));
const _getSafeFilename = /*#__PURE__*/ _interop_require_default(require("./getSafeFilename"));
const _imageResizer = /*#__PURE__*/ _interop_require_default(require("./imageResizer"));
const _isImage = /*#__PURE__*/ _interop_require_default(require("./isImage"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const generateFileData = async ({ collection: { config: collectionConfig }, config, data, overwriteExistingFiles, req, throwOnMissingFile })=>{
    if (!collectionConfig.upload) {
        return {
            data,
            files: []
        };
    }
    let file = req.files?.file || undefined;
    const { uploadEdits } = req.query || {};
    const { disableLocalStorage, formatOptions, imageSizes, resizeOptions, staticDir, trimOptions } = collectionConfig.upload;
    let staticPath = staticDir;
    if (staticDir.indexOf('/') !== 0) {
        staticPath = _path.default.resolve(config.paths.configDir, staticDir);
    }
    if (!file && uploadEdits && data) {
        const { filename } = data;
        const filePath = `${staticPath}/${filename}`;
        const response = await (0, _getFileByPath.default)(filePath);
        overwriteExistingFiles = true;
        file = response;
    }
    if (!file) {
        if (throwOnMissingFile) throw new _errors.MissingFile(req.t);
        return {
            data,
            files: []
        };
    }
    if (!disableLocalStorage) {
        _mkdirp.default.sync(staticPath);
    }
    let newData = data;
    const filesToSave = [];
    const fileData = {};
    const fileIsAnimated = file.mimetype === 'image/gif' || file.mimetype === 'image/webp';
    const cropData = typeof uploadEdits === 'object' && 'crop' in uploadEdits ? uploadEdits.crop : undefined;
    try {
        const fileSupportsResize = (0, _canResizeImage.default)(file.mimetype);
        let fsSafeName;
        let sharpFile;
        let dimensions;
        let fileBuffer;
        let ext;
        let mime;
        const isSharpRequired = fileSupportsResize && (resizeOptions || formatOptions || trimOptions);
        const sharpOptions = {};
        if (fileIsAnimated) sharpOptions.animated = true;
        if (isSharpRequired) {
            if (file.tempFilePath) {
                sharpFile = (0, _sharp.default)(file.tempFilePath, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
                ;
            } else {
                sharpFile = (0, _sharp.default)(file.data, sharpOptions).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
                ;
            }
            if (resizeOptions) {
                sharpFile = sharpFile.resize(resizeOptions);
            }
            if (formatOptions) {
                sharpFile = sharpFile.toFormat(formatOptions.format, formatOptions.options);
            }
            if (trimOptions) {
                sharpFile = sharpFile.trim(trimOptions);
            }
        }
        if ((0, _isImage.default)(file.mimetype)) {
            dimensions = await (0, _getImageSize.default)(file);
            fileData.width = dimensions.width;
            fileData.height = dimensions.height;
        }
        if (sharpFile) {
            const metadata = await sharpFile.metadata();
            fileBuffer = await sharpFile.toBuffer({
                resolveWithObject: true
            });
            ({ ext, mime } = await (0, _filetype.fromBuffer)(fileBuffer.data) // This is getting an incorrect gif height back.
            );
            fileData.width = fileBuffer.info.width;
            fileData.height = fileBuffer.info.height;
            fileData.filesize = fileBuffer.info.size;
            // Animated GIFs + WebP aggregate the height from every frame, so we need to use divide by number of pages
            if (metadata.pages) {
                fileData.height = fileBuffer.info.height / metadata.pages;
                fileData.filesize = fileBuffer.data.length;
            }
        } else {
            mime = file.mimetype;
            fileData.filesize = file.size;
            if (file.name.includes('.')) {
                ext = file.name.split('.').pop();
            } else {
                ext = '';
            }
        }
        // Adust SVG mime type. fromBuffer modifies it.
        if (mime === 'application/xml' && ext === 'svg') mime = 'image/svg+xml';
        fileData.mimeType = mime;
        const baseFilename = (0, _sanitizefilename.default)(file.name.substring(0, file.name.lastIndexOf('.')) || file.name);
        fsSafeName = `${baseFilename}${ext ? `.${ext}` : ''}`;
        if (!overwriteExistingFiles) {
            fsSafeName = await (0, _getSafeFilename.default)({
                collectionSlug: collectionConfig.slug,
                desiredFilename: fsSafeName,
                req,
                staticPath
            });
        }
        fileData.filename = fsSafeName;
        let fileForResize = file;
        if (isSharpRequired && cropData) {
            const { data: croppedImage, info } = await (0, _cropImage.default)({
                cropData,
                dimensions,
                file
            });
            filesToSave.push({
                buffer: croppedImage,
                path: `${staticPath}/${fsSafeName}`
            });
            fileForResize = {
                ...file,
                data: croppedImage,
                size: info.size
            };
            fileData.width = info.width;
            fileData.height = info.height;
            fileData.filesize = info.size;
            req.files.file = fileForResize;
        } else {
            filesToSave.push({
                buffer: fileBuffer?.data || file.data,
                path: `${staticPath}/${fsSafeName}`
            });
            if (file.tempFilePath) {
                await _fs.default.promises.writeFile(file.tempFilePath, fileBuffer?.data) // write fileBuffer to the temp path
                ;
            } else {
                // Assign the _possibly modified_ file to the request object
                req.files.file = {
                    ...file,
                    data: fileBuffer?.data || file.data,
                    size: fileBuffer?.info.size
                };
            }
        }
        if (Array.isArray(imageSizes) && fileSupportsResize) {
            req.payloadUploadSizes = {};
            const { sizeData, sizesToSave } = await (0, _imageResizer.default)({
                config: collectionConfig,
                dimensions: !cropData ? dimensions : {
                    ...dimensions,
                    height: fileData.height,
                    width: fileData.width
                },
                file: fileForResize,
                mimeType: fileData.mimeType,
                req,
                savedFilename: fsSafeName || file.name,
                staticPath
            });
            fileData.sizes = sizeData;
            filesToSave.push(...sizesToSave);
        }
    } catch (err) {
        console.error(err);
        throw new _errors.FileUploadError(req.t);
    }
    newData = {
        ...newData,
        ...fileData
    };
    return {
        data: newData,
        files: filesToSave
    };
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91cGxvYWRzL2dlbmVyYXRlRmlsZURhdGEudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBVcGxvYWRlZEZpbGUgfSBmcm9tICdleHByZXNzLWZpbGV1cGxvYWQnXG5pbXBvcnQgdHlwZSB7IFNoYXJwLCBTaGFycE9wdGlvbnMgfSBmcm9tICdzaGFycCdcblxuaW1wb3J0IHsgZnJvbUJ1ZmZlciB9IGZyb20gJ2ZpbGUtdHlwZSdcbmltcG9ydCBmcyBmcm9tICdmcydcbmltcG9ydCBta2RpcnAgZnJvbSAnbWtkaXJwJ1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCdcbmltcG9ydCBzYW5pdGl6ZSBmcm9tICdzYW5pdGl6ZS1maWxlbmFtZSdcbmltcG9ydCBzaGFycCBmcm9tICdzaGFycCdcblxuaW1wb3J0IHR5cGUgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi4vY29sbGVjdGlvbnMvY29uZmlnL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBTYW5pdGl6ZWRDb25maWcgfSBmcm9tICcuLi9jb25maWcvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFBheWxvYWRSZXF1ZXN0IH0gZnJvbSAnLi4vZXhwcmVzcy90eXBlcydcbmltcG9ydCB0eXBlIHsgRmlsZURhdGEsIEZpbGVUb1NhdmUsIFByb2JlZEltYWdlU2l6ZSB9IGZyb20gJy4vdHlwZXMnXG5cbmltcG9ydCB7IEZpbGVVcGxvYWRFcnJvciwgTWlzc2luZ0ZpbGUgfSBmcm9tICcuLi9lcnJvcnMnXG5pbXBvcnQgY2FuUmVzaXplSW1hZ2UgZnJvbSAnLi9jYW5SZXNpemVJbWFnZSdcbmltcG9ydCBjcm9wSW1hZ2UgZnJvbSAnLi9jcm9wSW1hZ2UnXG5pbXBvcnQgZ2V0RmlsZUJ5UGF0aCBmcm9tICcuL2dldEZpbGVCeVBhdGgnXG5pbXBvcnQgZ2V0SW1hZ2VTaXplIGZyb20gJy4vZ2V0SW1hZ2VTaXplJ1xuaW1wb3J0IGdldFNhZmVGaWxlTmFtZSBmcm9tICcuL2dldFNhZmVGaWxlbmFtZSdcbmltcG9ydCByZXNpemVBbmRUcmFuc2Zvcm1JbWFnZVNpemVzIGZyb20gJy4vaW1hZ2VSZXNpemVyJ1xuaW1wb3J0IGlzSW1hZ2UgZnJvbSAnLi9pc0ltYWdlJ1xuXG50eXBlIEFyZ3M8VD4gPSB7XG4gIGNvbGxlY3Rpb246IENvbGxlY3Rpb25cbiAgY29uZmlnOiBTYW5pdGl6ZWRDb25maWdcbiAgZGF0YTogVFxuICBvdmVyd3JpdGVFeGlzdGluZ0ZpbGVzPzogYm9vbGVhblxuICByZXE6IFBheWxvYWRSZXF1ZXN0XG4gIHRocm93T25NaXNzaW5nRmlsZT86IGJvb2xlYW5cbn1cblxudHlwZSBSZXN1bHQ8VD4gPSBQcm9taXNlPHtcbiAgZGF0YTogVFxuICBmaWxlczogRmlsZVRvU2F2ZVtdXG59PlxuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVGaWxlRGF0YSA9IGFzeW5jIDxUPih7XG4gIGNvbGxlY3Rpb246IHsgY29uZmlnOiBjb2xsZWN0aW9uQ29uZmlnIH0sXG4gIGNvbmZpZyxcbiAgZGF0YSxcbiAgb3ZlcndyaXRlRXhpc3RpbmdGaWxlcyxcbiAgcmVxLFxuICB0aHJvd09uTWlzc2luZ0ZpbGUsXG59OiBBcmdzPFQ+KTogUmVzdWx0PFQ+ID0+IHtcbiAgaWYgKCFjb2xsZWN0aW9uQ29uZmlnLnVwbG9hZCkge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhLFxuICAgICAgZmlsZXM6IFtdLFxuICAgIH1cbiAgfVxuXG4gIGxldCBmaWxlID0gcmVxLmZpbGVzPy5maWxlIHx8IHVuZGVmaW5lZFxuICBjb25zdCB7IHVwbG9hZEVkaXRzIH0gPSByZXEucXVlcnkgfHwge31cblxuICBjb25zdCB7IGRpc2FibGVMb2NhbFN0b3JhZ2UsIGZvcm1hdE9wdGlvbnMsIGltYWdlU2l6ZXMsIHJlc2l6ZU9wdGlvbnMsIHN0YXRpY0RpciwgdHJpbU9wdGlvbnMgfSA9XG4gICAgY29sbGVjdGlvbkNvbmZpZy51cGxvYWRcblxuICBsZXQgc3RhdGljUGF0aCA9IHN0YXRpY0RpclxuICBpZiAoc3RhdGljRGlyLmluZGV4T2YoJy8nKSAhPT0gMCkge1xuICAgIHN0YXRpY1BhdGggPSBwYXRoLnJlc29sdmUoY29uZmlnLnBhdGhzLmNvbmZpZ0Rpciwgc3RhdGljRGlyKVxuICB9XG5cbiAgaWYgKCFmaWxlICYmIHVwbG9hZEVkaXRzICYmIGRhdGEpIHtcbiAgICBjb25zdCB7IGZpbGVuYW1lIH0gPSBkYXRhIGFzIEZpbGVEYXRhXG4gICAgY29uc3QgZmlsZVBhdGggPSBgJHtzdGF0aWNQYXRofS8ke2ZpbGVuYW1lfWBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldEZpbGVCeVBhdGgoZmlsZVBhdGgpXG5cbiAgICBvdmVyd3JpdGVFeGlzdGluZ0ZpbGVzID0gdHJ1ZVxuICAgIGZpbGUgPSByZXNwb25zZSBhcyBVcGxvYWRlZEZpbGVcbiAgfVxuXG4gIGlmICghZmlsZSkge1xuICAgIGlmICh0aHJvd09uTWlzc2luZ0ZpbGUpIHRocm93IG5ldyBNaXNzaW5nRmlsZShyZXEudClcblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhLFxuICAgICAgZmlsZXM6IFtdLFxuICAgIH1cbiAgfVxuXG4gIGlmICghZGlzYWJsZUxvY2FsU3RvcmFnZSkge1xuICAgIG1rZGlycC5zeW5jKHN0YXRpY1BhdGgpXG4gIH1cblxuICBsZXQgbmV3RGF0YSA9IGRhdGFcbiAgY29uc3QgZmlsZXNUb1NhdmU6IEZpbGVUb1NhdmVbXSA9IFtdXG4gIGNvbnN0IGZpbGVEYXRhOiBQYXJ0aWFsPEZpbGVEYXRhPiA9IHt9XG4gIGNvbnN0IGZpbGVJc0FuaW1hdGVkID0gZmlsZS5taW1ldHlwZSA9PT0gJ2ltYWdlL2dpZicgfHwgZmlsZS5taW1ldHlwZSA9PT0gJ2ltYWdlL3dlYnAnXG4gIGNvbnN0IGNyb3BEYXRhID1cbiAgICB0eXBlb2YgdXBsb2FkRWRpdHMgPT09ICdvYmplY3QnICYmICdjcm9wJyBpbiB1cGxvYWRFZGl0cyA/IHVwbG9hZEVkaXRzLmNyb3AgOiB1bmRlZmluZWRcblxuICB0cnkge1xuICAgIGNvbnN0IGZpbGVTdXBwb3J0c1Jlc2l6ZSA9IGNhblJlc2l6ZUltYWdlKGZpbGUubWltZXR5cGUpXG4gICAgbGV0IGZzU2FmZU5hbWU6IHN0cmluZ1xuICAgIGxldCBzaGFycEZpbGU6IFNoYXJwIHwgdW5kZWZpbmVkXG4gICAgbGV0IGRpbWVuc2lvbnM6IFByb2JlZEltYWdlU2l6ZSB8IHVuZGVmaW5lZFxuICAgIGxldCBmaWxlQnVmZmVyXG4gICAgbGV0IGV4dFxuICAgIGxldCBtaW1lOiBzdHJpbmdcbiAgICBjb25zdCBpc1NoYXJwUmVxdWlyZWQgPSBmaWxlU3VwcG9ydHNSZXNpemUgJiYgKHJlc2l6ZU9wdGlvbnMgfHwgZm9ybWF0T3B0aW9ucyB8fCB0cmltT3B0aW9ucylcblxuICAgIGNvbnN0IHNoYXJwT3B0aW9uczogU2hhcnBPcHRpb25zID0ge31cblxuICAgIGlmIChmaWxlSXNBbmltYXRlZCkgc2hhcnBPcHRpb25zLmFuaW1hdGVkID0gdHJ1ZVxuXG4gICAgaWYgKGlzU2hhcnBSZXF1aXJlZCkge1xuICAgICAgaWYgKGZpbGUudGVtcEZpbGVQYXRoKSB7XG4gICAgICAgIHNoYXJwRmlsZSA9IHNoYXJwKGZpbGUudGVtcEZpbGVQYXRoLCBzaGFycE9wdGlvbnMpLnJvdGF0ZSgpIC8vIHBhc3Mgcm90YXRlKCkgdG8gYXV0by1yb3RhdGUgYmFzZWQgb24gRVhJRiBkYXRhLiBodHRwczovL2dpdGh1Yi5jb20vcGF5bG9hZGNtcy9wYXlsb2FkL3B1bGwvMzA4MVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hhcnBGaWxlID0gc2hhcnAoZmlsZS5kYXRhLCBzaGFycE9wdGlvbnMpLnJvdGF0ZSgpIC8vIHBhc3Mgcm90YXRlKCkgdG8gYXV0by1yb3RhdGUgYmFzZWQgb24gRVhJRiBkYXRhLiBodHRwczovL2dpdGh1Yi5jb20vcGF5bG9hZGNtcy9wYXlsb2FkL3B1bGwvMzA4MVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzaXplT3B0aW9ucykge1xuICAgICAgICBzaGFycEZpbGUgPSBzaGFycEZpbGUucmVzaXplKHJlc2l6ZU9wdGlvbnMpXG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0T3B0aW9ucykge1xuICAgICAgICBzaGFycEZpbGUgPSBzaGFycEZpbGUudG9Gb3JtYXQoZm9ybWF0T3B0aW9ucy5mb3JtYXQsIGZvcm1hdE9wdGlvbnMub3B0aW9ucylcbiAgICAgIH1cbiAgICAgIGlmICh0cmltT3B0aW9ucykge1xuICAgICAgICBzaGFycEZpbGUgPSBzaGFycEZpbGUudHJpbSh0cmltT3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNJbWFnZShmaWxlLm1pbWV0eXBlKSkge1xuICAgICAgZGltZW5zaW9ucyA9IGF3YWl0IGdldEltYWdlU2l6ZShmaWxlKVxuICAgICAgZmlsZURhdGEud2lkdGggPSBkaW1lbnNpb25zLndpZHRoXG4gICAgICBmaWxlRGF0YS5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodFxuICAgIH1cblxuICAgIGlmIChzaGFycEZpbGUpIHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgc2hhcnBGaWxlLm1ldGFkYXRhKClcbiAgICAgIGZpbGVCdWZmZXIgPSBhd2FpdCBzaGFycEZpbGUudG9CdWZmZXIoeyByZXNvbHZlV2l0aE9iamVjdDogdHJ1ZSB9KVxuICAgICAgOyh7IGV4dCwgbWltZSB9ID0gYXdhaXQgZnJvbUJ1ZmZlcihmaWxlQnVmZmVyLmRhdGEpKSAvLyBUaGlzIGlzIGdldHRpbmcgYW4gaW5jb3JyZWN0IGdpZiBoZWlnaHQgYmFjay5cbiAgICAgIGZpbGVEYXRhLndpZHRoID0gZmlsZUJ1ZmZlci5pbmZvLndpZHRoXG4gICAgICBmaWxlRGF0YS5oZWlnaHQgPSBmaWxlQnVmZmVyLmluZm8uaGVpZ2h0XG4gICAgICBmaWxlRGF0YS5maWxlc2l6ZSA9IGZpbGVCdWZmZXIuaW5mby5zaXplXG5cbiAgICAgIC8vIEFuaW1hdGVkIEdJRnMgKyBXZWJQIGFnZ3JlZ2F0ZSB0aGUgaGVpZ2h0IGZyb20gZXZlcnkgZnJhbWUsIHNvIHdlIG5lZWQgdG8gdXNlIGRpdmlkZSBieSBudW1iZXIgb2YgcGFnZXNcbiAgICAgIGlmIChtZXRhZGF0YS5wYWdlcykge1xuICAgICAgICBmaWxlRGF0YS5oZWlnaHQgPSBmaWxlQnVmZmVyLmluZm8uaGVpZ2h0IC8gbWV0YWRhdGEucGFnZXNcbiAgICAgICAgZmlsZURhdGEuZmlsZXNpemUgPSBmaWxlQnVmZmVyLmRhdGEubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbWUgPSBmaWxlLm1pbWV0eXBlXG4gICAgICBmaWxlRGF0YS5maWxlc2l6ZSA9IGZpbGUuc2l6ZVxuXG4gICAgICBpZiAoZmlsZS5uYW1lLmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgZXh0ID0gZmlsZS5uYW1lLnNwbGl0KCcuJykucG9wKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4dCA9ICcnXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWR1c3QgU1ZHIG1pbWUgdHlwZS4gZnJvbUJ1ZmZlciBtb2RpZmllcyBpdC5cbiAgICBpZiAobWltZSA9PT0gJ2FwcGxpY2F0aW9uL3htbCcgJiYgZXh0ID09PSAnc3ZnJykgbWltZSA9ICdpbWFnZS9zdmcreG1sJ1xuICAgIGZpbGVEYXRhLm1pbWVUeXBlID0gbWltZVxuXG4gICAgY29uc3QgYmFzZUZpbGVuYW1lID0gc2FuaXRpemUoZmlsZS5uYW1lLnN1YnN0cmluZygwLCBmaWxlLm5hbWUubGFzdEluZGV4T2YoJy4nKSkgfHwgZmlsZS5uYW1lKVxuICAgIGZzU2FmZU5hbWUgPSBgJHtiYXNlRmlsZW5hbWV9JHtleHQgPyBgLiR7ZXh0fWAgOiAnJ31gXG5cbiAgICBpZiAoIW92ZXJ3cml0ZUV4aXN0aW5nRmlsZXMpIHtcbiAgICAgIGZzU2FmZU5hbWUgPSBhd2FpdCBnZXRTYWZlRmlsZU5hbWUoe1xuICAgICAgICBjb2xsZWN0aW9uU2x1ZzogY29sbGVjdGlvbkNvbmZpZy5zbHVnLFxuICAgICAgICBkZXNpcmVkRmlsZW5hbWU6IGZzU2FmZU5hbWUsXG4gICAgICAgIHJlcSxcbiAgICAgICAgc3RhdGljUGF0aCxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZmlsZURhdGEuZmlsZW5hbWUgPSBmc1NhZmVOYW1lXG4gICAgbGV0IGZpbGVGb3JSZXNpemUgPSBmaWxlXG5cbiAgICBpZiAoaXNTaGFycFJlcXVpcmVkICYmIGNyb3BEYXRhKSB7XG4gICAgICBjb25zdCB7IGRhdGE6IGNyb3BwZWRJbWFnZSwgaW5mbyB9ID0gYXdhaXQgY3JvcEltYWdlKHsgY3JvcERhdGEsIGRpbWVuc2lvbnMsIGZpbGUgfSlcblxuICAgICAgZmlsZXNUb1NhdmUucHVzaCh7XG4gICAgICAgIGJ1ZmZlcjogY3JvcHBlZEltYWdlLFxuICAgICAgICBwYXRoOiBgJHtzdGF0aWNQYXRofS8ke2ZzU2FmZU5hbWV9YCxcbiAgICAgIH0pXG5cbiAgICAgIGZpbGVGb3JSZXNpemUgPSB7XG4gICAgICAgIC4uLmZpbGUsXG4gICAgICAgIGRhdGE6IGNyb3BwZWRJbWFnZSxcbiAgICAgICAgc2l6ZTogaW5mby5zaXplLFxuICAgICAgfVxuICAgICAgZmlsZURhdGEud2lkdGggPSBpbmZvLndpZHRoXG4gICAgICBmaWxlRGF0YS5oZWlnaHQgPSBpbmZvLmhlaWdodFxuICAgICAgZmlsZURhdGEuZmlsZXNpemUgPSBpbmZvLnNpemVcbiAgICAgIHJlcS5maWxlcy5maWxlID0gZmlsZUZvclJlc2l6ZVxuICAgIH0gZWxzZSB7XG4gICAgICBmaWxlc1RvU2F2ZS5wdXNoKHtcbiAgICAgICAgYnVmZmVyOiBmaWxlQnVmZmVyPy5kYXRhIHx8IGZpbGUuZGF0YSxcbiAgICAgICAgcGF0aDogYCR7c3RhdGljUGF0aH0vJHtmc1NhZmVOYW1lfWAsXG4gICAgICB9KVxuXG4gICAgICBpZiAoZmlsZS50ZW1wRmlsZVBhdGgpIHtcbiAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMud3JpdGVGaWxlKGZpbGUudGVtcEZpbGVQYXRoLCBmaWxlQnVmZmVyPy5kYXRhKSAvLyB3cml0ZSBmaWxlQnVmZmVyIHRvIHRoZSB0ZW1wIHBhdGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFzc2lnbiB0aGUgX3Bvc3NpYmx5IG1vZGlmaWVkXyBmaWxlIHRvIHRoZSByZXF1ZXN0IG9iamVjdFxuICAgICAgICByZXEuZmlsZXMuZmlsZSA9IHtcbiAgICAgICAgICAuLi5maWxlLFxuICAgICAgICAgIGRhdGE6IGZpbGVCdWZmZXI/LmRhdGEgfHwgZmlsZS5kYXRhLFxuICAgICAgICAgIHNpemU6IGZpbGVCdWZmZXI/LmluZm8uc2l6ZSxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGltYWdlU2l6ZXMpICYmIGZpbGVTdXBwb3J0c1Jlc2l6ZSkge1xuICAgICAgcmVxLnBheWxvYWRVcGxvYWRTaXplcyA9IHt9XG4gICAgICBjb25zdCB7IHNpemVEYXRhLCBzaXplc1RvU2F2ZSB9ID0gYXdhaXQgcmVzaXplQW5kVHJhbnNmb3JtSW1hZ2VTaXplcyh7XG4gICAgICAgIGNvbmZpZzogY29sbGVjdGlvbkNvbmZpZyxcbiAgICAgICAgZGltZW5zaW9uczogIWNyb3BEYXRhXG4gICAgICAgICAgPyBkaW1lbnNpb25zXG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIC4uLmRpbWVuc2lvbnMsXG4gICAgICAgICAgICAgIGhlaWdodDogZmlsZURhdGEuaGVpZ2h0LFxuICAgICAgICAgICAgICB3aWR0aDogZmlsZURhdGEud2lkdGgsXG4gICAgICAgICAgICB9LFxuICAgICAgICBmaWxlOiBmaWxlRm9yUmVzaXplLFxuICAgICAgICBtaW1lVHlwZTogZmlsZURhdGEubWltZVR5cGUsXG4gICAgICAgIHJlcSxcbiAgICAgICAgc2F2ZWRGaWxlbmFtZTogZnNTYWZlTmFtZSB8fCBmaWxlLm5hbWUsXG4gICAgICAgIHN0YXRpY1BhdGgsXG4gICAgICB9KVxuXG4gICAgICBmaWxlRGF0YS5zaXplcyA9IHNpemVEYXRhXG4gICAgICBmaWxlc1RvU2F2ZS5wdXNoKC4uLnNpemVzVG9TYXZlKVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgdGhyb3cgbmV3IEZpbGVVcGxvYWRFcnJvcihyZXEudClcbiAgfVxuXG4gIG5ld0RhdGEgPSB7XG4gICAgLi4ubmV3RGF0YSxcbiAgICAuLi5maWxlRGF0YSxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGF0YTogbmV3RGF0YSxcbiAgICBmaWxlczogZmlsZXNUb1NhdmUsXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJnZW5lcmF0ZUZpbGVEYXRhIiwiY29sbGVjdGlvbiIsImNvbmZpZyIsImNvbGxlY3Rpb25Db25maWciLCJkYXRhIiwib3ZlcndyaXRlRXhpc3RpbmdGaWxlcyIsInJlcSIsInRocm93T25NaXNzaW5nRmlsZSIsInVwbG9hZCIsImZpbGVzIiwiZmlsZSIsInVuZGVmaW5lZCIsInVwbG9hZEVkaXRzIiwicXVlcnkiLCJkaXNhYmxlTG9jYWxTdG9yYWdlIiwiZm9ybWF0T3B0aW9ucyIsImltYWdlU2l6ZXMiLCJyZXNpemVPcHRpb25zIiwic3RhdGljRGlyIiwidHJpbU9wdGlvbnMiLCJzdGF0aWNQYXRoIiwiaW5kZXhPZiIsInBhdGgiLCJyZXNvbHZlIiwicGF0aHMiLCJjb25maWdEaXIiLCJmaWxlbmFtZSIsImZpbGVQYXRoIiwicmVzcG9uc2UiLCJnZXRGaWxlQnlQYXRoIiwiTWlzc2luZ0ZpbGUiLCJ0IiwibWtkaXJwIiwic3luYyIsIm5ld0RhdGEiLCJmaWxlc1RvU2F2ZSIsImZpbGVEYXRhIiwiZmlsZUlzQW5pbWF0ZWQiLCJtaW1ldHlwZSIsImNyb3BEYXRhIiwiY3JvcCIsImZpbGVTdXBwb3J0c1Jlc2l6ZSIsImNhblJlc2l6ZUltYWdlIiwiZnNTYWZlTmFtZSIsInNoYXJwRmlsZSIsImRpbWVuc2lvbnMiLCJmaWxlQnVmZmVyIiwiZXh0IiwibWltZSIsImlzU2hhcnBSZXF1aXJlZCIsInNoYXJwT3B0aW9ucyIsImFuaW1hdGVkIiwidGVtcEZpbGVQYXRoIiwic2hhcnAiLCJyb3RhdGUiLCJyZXNpemUiLCJ0b0Zvcm1hdCIsImZvcm1hdCIsIm9wdGlvbnMiLCJ0cmltIiwiaXNJbWFnZSIsImdldEltYWdlU2l6ZSIsIndpZHRoIiwiaGVpZ2h0IiwibWV0YWRhdGEiLCJ0b0J1ZmZlciIsInJlc29sdmVXaXRoT2JqZWN0IiwiZnJvbUJ1ZmZlciIsImluZm8iLCJmaWxlc2l6ZSIsInNpemUiLCJwYWdlcyIsImxlbmd0aCIsIm5hbWUiLCJpbmNsdWRlcyIsInNwbGl0IiwicG9wIiwibWltZVR5cGUiLCJiYXNlRmlsZW5hbWUiLCJzYW5pdGl6ZSIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwiZ2V0U2FmZUZpbGVOYW1lIiwiY29sbGVjdGlvblNsdWciLCJzbHVnIiwiZGVzaXJlZEZpbGVuYW1lIiwiZmlsZUZvclJlc2l6ZSIsImNyb3BwZWRJbWFnZSIsImNyb3BJbWFnZSIsInB1c2giLCJidWZmZXIiLCJmcyIsInByb21pc2VzIiwid3JpdGVGaWxlIiwiQXJyYXkiLCJpc0FycmF5IiwicGF5bG9hZFVwbG9hZFNpemVzIiwic2l6ZURhdGEiLCJzaXplc1RvU2F2ZSIsInJlc2l6ZUFuZFRyYW5zZm9ybUltYWdlU2l6ZXMiLCJzYXZlZEZpbGVuYW1lIiwic2l6ZXMiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJGaWxlVXBsb2FkRXJyb3IiXSwibWFwcGluZ3MiOiI7Ozs7K0JBc0NhQTs7O2VBQUFBOzs7MEJBbkNjOzJEQUNaOytEQUNJOzZEQUNGO3lFQUNJOzhEQUNIO3dCQU8yQjt1RUFDbEI7a0VBQ0w7c0VBQ0k7cUVBQ0Q7d0VBQ0c7cUVBQ2E7Z0VBQ3JCOzs7Ozs7QUFnQmIsTUFBTUEsbUJBQW1CLE9BQVUsRUFDeENDLFlBQVksRUFBRUMsUUFBUUMsZ0JBQWdCLEVBQUUsRUFDeENELE1BQU0sRUFDTkUsSUFBSSxFQUNKQyxzQkFBc0IsRUFDdEJDLEdBQUcsRUFDSEMsa0JBQWtCLEVBQ1Y7SUFDUixJQUFJLENBQUNKLGlCQUFpQkssTUFBTSxFQUFFO1FBQzVCLE9BQU87WUFDTEo7WUFDQUssT0FBTyxFQUFFO1FBQ1g7SUFDRjtJQUVBLElBQUlDLE9BQU9KLElBQUlHLEtBQUssRUFBRUMsUUFBUUM7SUFDOUIsTUFBTSxFQUFFQyxXQUFXLEVBQUUsR0FBR04sSUFBSU8sS0FBSyxJQUFJLENBQUM7SUFFdEMsTUFBTSxFQUFFQyxtQkFBbUIsRUFBRUMsYUFBYSxFQUFFQyxVQUFVLEVBQUVDLGFBQWEsRUFBRUMsU0FBUyxFQUFFQyxXQUFXLEVBQUUsR0FDN0ZoQixpQkFBaUJLLE1BQU07SUFFekIsSUFBSVksYUFBYUY7SUFDakIsSUFBSUEsVUFBVUcsT0FBTyxDQUFDLFNBQVMsR0FBRztRQUNoQ0QsYUFBYUUsYUFBSSxDQUFDQyxPQUFPLENBQUNyQixPQUFPc0IsS0FBSyxDQUFDQyxTQUFTLEVBQUVQO0lBQ3BEO0lBRUEsSUFBSSxDQUFDUixRQUFRRSxlQUFlUixNQUFNO1FBQ2hDLE1BQU0sRUFBRXNCLFFBQVEsRUFBRSxHQUFHdEI7UUFDckIsTUFBTXVCLFdBQVcsQ0FBQyxFQUFFUCxXQUFXLENBQUMsRUFBRU0sU0FBUyxDQUFDO1FBQzVDLE1BQU1FLFdBQVcsTUFBTUMsSUFBQUEsc0JBQWEsRUFBQ0Y7UUFFckN0Qix5QkFBeUI7UUFDekJLLE9BQU9rQjtJQUNUO0lBRUEsSUFBSSxDQUFDbEIsTUFBTTtRQUNULElBQUlILG9CQUFvQixNQUFNLElBQUl1QixtQkFBVyxDQUFDeEIsSUFBSXlCLENBQUM7UUFFbkQsT0FBTztZQUNMM0I7WUFDQUssT0FBTyxFQUFFO1FBQ1g7SUFDRjtJQUVBLElBQUksQ0FBQ0sscUJBQXFCO1FBQ3hCa0IsZUFBTSxDQUFDQyxJQUFJLENBQUNiO0lBQ2Q7SUFFQSxJQUFJYyxVQUFVOUI7SUFDZCxNQUFNK0IsY0FBNEIsRUFBRTtJQUNwQyxNQUFNQyxXQUE4QixDQUFDO0lBQ3JDLE1BQU1DLGlCQUFpQjNCLEtBQUs0QixRQUFRLEtBQUssZUFBZTVCLEtBQUs0QixRQUFRLEtBQUs7SUFDMUUsTUFBTUMsV0FDSixPQUFPM0IsZ0JBQWdCLFlBQVksVUFBVUEsY0FBY0EsWUFBWTRCLElBQUksR0FBRzdCO0lBRWhGLElBQUk7UUFDRixNQUFNOEIscUJBQXFCQyxJQUFBQSx1QkFBYyxFQUFDaEMsS0FBSzRCLFFBQVE7UUFDdkQsSUFBSUs7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osSUFBSUM7UUFDSixJQUFJQztRQUNKLElBQUlDO1FBQ0osTUFBTUMsa0JBQWtCUixzQkFBdUJ4QixDQUFBQSxpQkFBaUJGLGlCQUFpQkksV0FBVTtRQUUzRixNQUFNK0IsZUFBNkIsQ0FBQztRQUVwQyxJQUFJYixnQkFBZ0JhLGFBQWFDLFFBQVEsR0FBRztRQUU1QyxJQUFJRixpQkFBaUI7WUFDbkIsSUFBSXZDLEtBQUswQyxZQUFZLEVBQUU7Z0JBQ3JCUixZQUFZUyxJQUFBQSxjQUFLLEVBQUMzQyxLQUFLMEMsWUFBWSxFQUFFRixjQUFjSSxNQUFNLEdBQUcsbUdBQW1HOztZQUNqSyxPQUFPO2dCQUNMVixZQUFZUyxJQUFBQSxjQUFLLEVBQUMzQyxLQUFLTixJQUFJLEVBQUU4QyxjQUFjSSxNQUFNLEdBQUcsbUdBQW1HOztZQUN6SjtZQUVBLElBQUlyQyxlQUFlO2dCQUNqQjJCLFlBQVlBLFVBQVVXLE1BQU0sQ0FBQ3RDO1lBQy9CO1lBQ0EsSUFBSUYsZUFBZTtnQkFDakI2QixZQUFZQSxVQUFVWSxRQUFRLENBQUN6QyxjQUFjMEMsTUFBTSxFQUFFMUMsY0FBYzJDLE9BQU87WUFDNUU7WUFDQSxJQUFJdkMsYUFBYTtnQkFDZnlCLFlBQVlBLFVBQVVlLElBQUksQ0FBQ3hDO1lBQzdCO1FBQ0Y7UUFFQSxJQUFJeUMsSUFBQUEsZ0JBQU8sRUFBQ2xELEtBQUs0QixRQUFRLEdBQUc7WUFDMUJPLGFBQWEsTUFBTWdCLElBQUFBLHFCQUFZLEVBQUNuRDtZQUNoQzBCLFNBQVMwQixLQUFLLEdBQUdqQixXQUFXaUIsS0FBSztZQUNqQzFCLFNBQVMyQixNQUFNLEdBQUdsQixXQUFXa0IsTUFBTTtRQUNyQztRQUVBLElBQUluQixXQUFXO1lBQ2IsTUFBTW9CLFdBQVcsTUFBTXBCLFVBQVVvQixRQUFRO1lBQ3pDbEIsYUFBYSxNQUFNRixVQUFVcUIsUUFBUSxDQUFDO2dCQUFFQyxtQkFBbUI7WUFBSztZQUM5RCxDQUFBLEVBQUVuQixHQUFHLEVBQUVDLElBQUksRUFBRSxHQUFHLE1BQU1tQixJQUFBQSxvQkFBVSxFQUFDckIsV0FBVzFDLElBQUksRUFBRyxnREFBZ0Q7WUFBbkQ7WUFDbERnQyxTQUFTMEIsS0FBSyxHQUFHaEIsV0FBV3NCLElBQUksQ0FBQ04sS0FBSztZQUN0QzFCLFNBQVMyQixNQUFNLEdBQUdqQixXQUFXc0IsSUFBSSxDQUFDTCxNQUFNO1lBQ3hDM0IsU0FBU2lDLFFBQVEsR0FBR3ZCLFdBQVdzQixJQUFJLENBQUNFLElBQUk7WUFFeEMsMEdBQTBHO1lBQzFHLElBQUlOLFNBQVNPLEtBQUssRUFBRTtnQkFDbEJuQyxTQUFTMkIsTUFBTSxHQUFHakIsV0FBV3NCLElBQUksQ0FBQ0wsTUFBTSxHQUFHQyxTQUFTTyxLQUFLO2dCQUN6RG5DLFNBQVNpQyxRQUFRLEdBQUd2QixXQUFXMUMsSUFBSSxDQUFDb0UsTUFBTTtZQUM1QztRQUNGLE9BQU87WUFDTHhCLE9BQU90QyxLQUFLNEIsUUFBUTtZQUNwQkYsU0FBU2lDLFFBQVEsR0FBRzNELEtBQUs0RCxJQUFJO1lBRTdCLElBQUk1RCxLQUFLK0QsSUFBSSxDQUFDQyxRQUFRLENBQUMsTUFBTTtnQkFDM0IzQixNQUFNckMsS0FBSytELElBQUksQ0FBQ0UsS0FBSyxDQUFDLEtBQUtDLEdBQUc7WUFDaEMsT0FBTztnQkFDTDdCLE1BQU07WUFDUjtRQUNGO1FBRUEsK0NBQStDO1FBQy9DLElBQUlDLFNBQVMscUJBQXFCRCxRQUFRLE9BQU9DLE9BQU87UUFDeERaLFNBQVN5QyxRQUFRLEdBQUc3QjtRQUVwQixNQUFNOEIsZUFBZUMsSUFBQUEseUJBQVEsRUFBQ3JFLEtBQUsrRCxJQUFJLENBQUNPLFNBQVMsQ0FBQyxHQUFHdEUsS0FBSytELElBQUksQ0FBQ1EsV0FBVyxDQUFDLFNBQVN2RSxLQUFLK0QsSUFBSTtRQUM3RjlCLGFBQWEsQ0FBQyxFQUFFbUMsYUFBYSxFQUFFL0IsTUFBTSxDQUFDLENBQUMsRUFBRUEsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBRXJELElBQUksQ0FBQzFDLHdCQUF3QjtZQUMzQnNDLGFBQWEsTUFBTXVDLElBQUFBLHdCQUFlLEVBQUM7Z0JBQ2pDQyxnQkFBZ0JoRixpQkFBaUJpRixJQUFJO2dCQUNyQ0MsaUJBQWlCMUM7Z0JBQ2pCckM7Z0JBQ0FjO1lBQ0Y7UUFDRjtRQUVBZ0IsU0FBU1YsUUFBUSxHQUFHaUI7UUFDcEIsSUFBSTJDLGdCQUFnQjVFO1FBRXBCLElBQUl1QyxtQkFBbUJWLFVBQVU7WUFDL0IsTUFBTSxFQUFFbkMsTUFBTW1GLFlBQVksRUFBRW5CLElBQUksRUFBRSxHQUFHLE1BQU1vQixJQUFBQSxrQkFBUyxFQUFDO2dCQUFFakQ7Z0JBQVVNO2dCQUFZbkM7WUFBSztZQUVsRnlCLFlBQVlzRCxJQUFJLENBQUM7Z0JBQ2ZDLFFBQVFIO2dCQUNSakUsTUFBTSxDQUFDLEVBQUVGLFdBQVcsQ0FBQyxFQUFFdUIsV0FBVyxDQUFDO1lBQ3JDO1lBRUEyQyxnQkFBZ0I7Z0JBQ2QsR0FBRzVFLElBQUk7Z0JBQ1BOLE1BQU1tRjtnQkFDTmpCLE1BQU1GLEtBQUtFLElBQUk7WUFDakI7WUFDQWxDLFNBQVMwQixLQUFLLEdBQUdNLEtBQUtOLEtBQUs7WUFDM0IxQixTQUFTMkIsTUFBTSxHQUFHSyxLQUFLTCxNQUFNO1lBQzdCM0IsU0FBU2lDLFFBQVEsR0FBR0QsS0FBS0UsSUFBSTtZQUM3QmhFLElBQUlHLEtBQUssQ0FBQ0MsSUFBSSxHQUFHNEU7UUFDbkIsT0FBTztZQUNMbkQsWUFBWXNELElBQUksQ0FBQztnQkFDZkMsUUFBUTVDLFlBQVkxQyxRQUFRTSxLQUFLTixJQUFJO2dCQUNyQ2tCLE1BQU0sQ0FBQyxFQUFFRixXQUFXLENBQUMsRUFBRXVCLFdBQVcsQ0FBQztZQUNyQztZQUVBLElBQUlqQyxLQUFLMEMsWUFBWSxFQUFFO2dCQUNyQixNQUFNdUMsV0FBRSxDQUFDQyxRQUFRLENBQUNDLFNBQVMsQ0FBQ25GLEtBQUswQyxZQUFZLEVBQUVOLFlBQVkxQyxNQUFNLG9DQUFvQzs7WUFDdkcsT0FBTztnQkFDTCw0REFBNEQ7Z0JBQzVERSxJQUFJRyxLQUFLLENBQUNDLElBQUksR0FBRztvQkFDZixHQUFHQSxJQUFJO29CQUNQTixNQUFNMEMsWUFBWTFDLFFBQVFNLEtBQUtOLElBQUk7b0JBQ25Da0UsTUFBTXhCLFlBQVlzQixLQUFLRTtnQkFDekI7WUFDRjtRQUNGO1FBRUEsSUFBSXdCLE1BQU1DLE9BQU8sQ0FBQy9FLGVBQWV5QixvQkFBb0I7WUFDbkRuQyxJQUFJMEYsa0JBQWtCLEdBQUcsQ0FBQztZQUMxQixNQUFNLEVBQUVDLFFBQVEsRUFBRUMsV0FBVyxFQUFFLEdBQUcsTUFBTUMsSUFBQUEscUJBQTRCLEVBQUM7Z0JBQ25FakcsUUFBUUM7Z0JBQ1IwQyxZQUFZLENBQUNOLFdBQ1RNLGFBQ0E7b0JBQ0UsR0FBR0EsVUFBVTtvQkFDYmtCLFFBQVEzQixTQUFTMkIsTUFBTTtvQkFDdkJELE9BQU8xQixTQUFTMEIsS0FBSztnQkFDdkI7Z0JBQ0pwRCxNQUFNNEU7Z0JBQ05ULFVBQVV6QyxTQUFTeUMsUUFBUTtnQkFDM0J2RTtnQkFDQThGLGVBQWV6RCxjQUFjakMsS0FBSytELElBQUk7Z0JBQ3RDckQ7WUFDRjtZQUVBZ0IsU0FBU2lFLEtBQUssR0FBR0o7WUFDakI5RCxZQUFZc0QsSUFBSSxJQUFJUztRQUN0QjtJQUNGLEVBQUUsT0FBT0ksS0FBSztRQUNaQyxRQUFRQyxLQUFLLENBQUNGO1FBQ2QsTUFBTSxJQUFJRyx1QkFBZSxDQUFDbkcsSUFBSXlCLENBQUM7SUFDakM7SUFFQUcsVUFBVTtRQUNSLEdBQUdBLE9BQU87UUFDVixHQUFHRSxRQUFRO0lBQ2I7SUFFQSxPQUFPO1FBQ0xoQyxNQUFNOEI7UUFDTnpCLE9BQU8wQjtJQUNUO0FBQ0YifQ==