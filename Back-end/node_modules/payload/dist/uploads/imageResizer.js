"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, /**
 * For the provided image sizes, handle the resizing and the transforms
 * (format, trim, etc.) of each requested image size and return the result object.
 * This only handles the image sizes. The transforms of the original image
 * are handled in {@link ./generateFileData.ts}.
 *
 * The image will be resized according to the provided
 * resize config. If no image sizes are requested, the resolved data will be empty.
 * For every image that dos not need to be resized, an result object with `null`
 * parameters will be returned.
 *
 * @param resizeConfig - the resize config
 * @returns the result of the resize operation(s)
 */ "default", {
    enumerable: true,
    get: function() {
        return resizeAndTransformImageSizes;
    }
});
const _filetype = require("file-type");
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _sanitizefilename = /*#__PURE__*/ _interop_require_default(require("sanitize-filename"));
const _sharp = /*#__PURE__*/ _interop_require_default(require("sharp"));
const _isNumber = require("../utilities/isNumber");
const _fileExists = /*#__PURE__*/ _interop_require_default(require("./fileExists"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Sanitize the image name and extract the extension from the source image
 *
 * @param sourceImage - the source image
 * @returns the sanitized name and extension
 */ const getSanitizedImageData = (sourceImage)=>{
    const extension = sourceImage.split('.').pop();
    const name = (0, _sanitizefilename.default)(sourceImage.substring(0, sourceImage.lastIndexOf('.')) || sourceImage);
    return {
        name,
        ext: extension
    };
};
/**
 * Create a new image name based on the output image name, the dimensions and
 * the extension.
 *
 * Ignore the fact that duplicate names could happen if the there is one
 * size with `width AND height` and one with only `height OR width`. Because
 * space is expensive, we will reuse the same image for both sizes.
 *
 * @param outputImageName - the sanitized image name
 * @param bufferInfo - the buffer info
 * @param extension - the extension to use
 * @returns the new image name that is not taken
 */ const createImageName = (outputImageName, { height, width }, extension)=>`${outputImageName}-${width}x${height}.${extension}`;
/**
 * Create the result object for the image resize operation based on the
 * provided parameters. If the name is not provided, an empty result object
 * is returned.
 *
 * @param name - the name of the image
 * @param filename - the filename of the image
 * @param width - the width of the image
 * @param height - the height of the image
 * @param filesize - the filesize of the image
 * @param mimeType - the mime type of the image
 * @param sizesToSave - the sizes to save
 * @returns the result object
 */ const createResult = (name, filename = null, width = null, height = null, filesize = null, mimeType = null, sizesToSave = [])=>({
        sizeData: {
            [name]: {
                filename,
                filesize,
                height,
                mimeType,
                width
            }
        },
        sizesToSave
    });
/**
 * Check if the image needs to be resized according to the requested dimensions
 * and the original image size. If the resize options withoutEnlargement or withoutReduction are provided,
 * the image will be resized regardless of the requested dimensions, given that the
 * width or height to be resized is provided.
 *
 * @param resizeConfig - object containing the requested dimensions and resize options
 * @param original - the original image size
 * @returns true if the image needs to be resized, false otherwise
 */ const needsResize = ({ height: desiredHeight, width: desiredWidth, withoutEnlargement, withoutReduction }, original)=>{
    // allow enlargement or prevent reduction (our default is to prevent
    // enlargement and allow reduction)
    if (withoutEnlargement !== undefined || withoutReduction !== undefined) {
        return true // needs resize
        ;
    }
    const isWidthOrHeightNotDefined = !desiredHeight || !desiredWidth;
    if (isWidthOrHeightNotDefined) {
        // If with and height are not defined, it means there is a format conversion
        // and the image needs to be "resized" (transformed).
        return true // needs resize
        ;
    }
    const hasInsufficientWidth = original.width < desiredWidth;
    const hasInsufficientHeight = original.height < desiredHeight;
    if (hasInsufficientWidth && hasInsufficientHeight) {
        // doesn't need resize - prevent enlargement. This should only happen if both width and height are insufficient.
        // if only one dimension is insufficient and the other is sufficient, resizing needs to happen, as the image
        // should be resized to the sufficient dimension.
        return false;
    }
    return true // needs resize
    ;
};
async function resizeAndTransformImageSizes({ config, dimensions, file, mimeType, req, savedFilename, staticPath }) {
    const { imageSizes } = config.upload;
    // Noting to resize here so return as early as possible
    if (!imageSizes) return {
        sizeData: {},
        sizesToSave: []
    };
    const sharpBase = (0, _sharp.default)(file.tempFilePath || file.data).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
    ;
    const results = await Promise.all(imageSizes.map(async (imageResizeConfig)=>{
        // This checks if a resize should happen. If not, the resized image will be
        // skipped COMPLETELY and thus will not be included in the resulting images.
        // All further format/trim options will thus be skipped as well.
        if (!needsResize(imageResizeConfig, dimensions)) {
            return createResult(imageResizeConfig.name);
        }
        let resized = sharpBase.clone();
        const hasEdits = req.query?.uploadEdits;
        if (hasEdits && imageResizeConfig.width && imageResizeConfig.height) {
            const { height, width } = imageResizeConfig;
            const targetAspectRatio = width / height;
            const originalAspectRatio = dimensions.width / dimensions.height;
            if (originalAspectRatio === targetAspectRatio) {
                resized = resized.resize(imageResizeConfig);
            } else {
                const focalPoint = {
                    x: 0.5,
                    y: 0.5
                };
                if (req.query.uploadEdits?.focalPoint) {
                    if ((0, _isNumber.isNumber)(req.query.uploadEdits.focalPoint?.x)) {
                        focalPoint.x = req.query.uploadEdits.focalPoint.x;
                    }
                    if ((0, _isNumber.isNumber)(req.query.uploadEdits.focalPoint?.y)) {
                        focalPoint.y = req.query.uploadEdits.focalPoint.y;
                    }
                }
                const prioritizeHeight = originalAspectRatio > targetAspectRatio;
                const { info } = await resized.resize({
                    height: prioritizeHeight ? height : null,
                    width: prioritizeHeight ? null : width
                }).toBuffer({
                    resolveWithObject: true
                });
                const maxOffsetX = Math.max(info.width - width, 0);
                const maxOffsetY = Math.max(info.height - height, 0);
                const focalPointX = Math.floor(info.width / 100 * focalPoint.x);
                const focalPointY = Math.floor(info.height / 100 * focalPoint.y);
                const offsetX = Math.min(Math.max(focalPointX - width / 2, 0), maxOffsetX);
                const offsetY = Math.min(Math.max(focalPointY - height / 2, 0), maxOffsetY);
                resized = resized.extract({
                    height,
                    left: offsetX,
                    top: offsetY,
                    width
                });
            }
        } else {
            resized = resized.resize(imageResizeConfig);
        }
        if (imageResizeConfig.formatOptions) {
            resized = resized.toFormat(imageResizeConfig.formatOptions.format, imageResizeConfig.formatOptions.options);
        }
        if (imageResizeConfig.trimOptions) {
            resized = resized.trim(imageResizeConfig.trimOptions);
        }
        const { data: bufferData, info: bufferInfo } = await resized.toBuffer({
            resolveWithObject: true
        });
        const sanitizedImage = getSanitizedImageData(savedFilename);
        if (req.payloadUploadSizes) {
            req.payloadUploadSizes[imageResizeConfig.name] = bufferData;
        }
        const mimeInfo = await (0, _filetype.fromBuffer)(bufferData);
        const imageNameWithDimensions = createImageName(sanitizedImage.name, bufferInfo, mimeInfo?.ext || sanitizedImage.ext);
        const imagePath = `${staticPath}/${imageNameWithDimensions}`;
        if (await (0, _fileExists.default)(imagePath)) {
            try {
                _fs.default.unlinkSync(imagePath);
            } catch  {
            // Ignore unlink errors
            }
        }
        const { height, size, width } = bufferInfo;
        return createResult(imageResizeConfig.name, imageNameWithDimensions, width, height, size, mimeInfo?.mime || mimeType, [
            {
                buffer: bufferData,
                path: imagePath
            }
        ]);
    }));
    return results.reduce((acc, result)=>{
        Object.assign(acc.sizeData, result.sizeData);
        acc.sizesToSave.push(...result.sizesToSave);
        return acc;
    }, {
        sizeData: {},
        sizesToSave: []
    });
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91cGxvYWRzL2ltYWdlUmVzaXplci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFVwbG9hZGVkRmlsZSB9IGZyb20gJ2V4cHJlc3MtZmlsZXVwbG9hZCdcbmltcG9ydCB0eXBlIHsgT3V0cHV0SW5mbyB9IGZyb20gJ3NoYXJwJ1xuXG5pbXBvcnQgeyBmcm9tQnVmZmVyIH0gZnJvbSAnZmlsZS10eXBlJ1xuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xuaW1wb3J0IHNhbml0aXplIGZyb20gJ3Nhbml0aXplLWZpbGVuYW1lJ1xuaW1wb3J0IHNoYXJwIGZyb20gJ3NoYXJwJ1xuXG5pbXBvcnQgdHlwZSB7IFVwbG9hZEVkaXRzIH0gZnJvbSAnLi4vYWRtaW4vY29tcG9uZW50cy92aWV3cy9jb2xsZWN0aW9ucy9FZGl0L3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBTYW5pdGl6ZWRDb2xsZWN0aW9uQ29uZmlnIH0gZnJvbSAnLi4vY29sbGVjdGlvbnMvY29uZmlnL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBQYXlsb2FkUmVxdWVzdCB9IGZyb20gJy4uL2V4cHJlc3MvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IEZpbGVTaXplLCBGaWxlU2l6ZXMsIEZpbGVUb1NhdmUsIEltYWdlU2l6ZSwgUHJvYmVkSW1hZ2VTaXplIH0gZnJvbSAnLi90eXBlcydcblxuaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNOdW1iZXInXG5pbXBvcnQgZmlsZUV4aXN0cyBmcm9tICcuL2ZpbGVFeGlzdHMnXG5cbnR5cGUgUmVzaXplQXJncyA9IHtcbiAgY29uZmlnOiBTYW5pdGl6ZWRDb2xsZWN0aW9uQ29uZmlnXG4gIGRpbWVuc2lvbnM6IFByb2JlZEltYWdlU2l6ZVxuICBmaWxlOiBVcGxvYWRlZEZpbGVcbiAgbWltZVR5cGU6IHN0cmluZ1xuICByZXE6IFBheWxvYWRSZXF1ZXN0ICYge1xuICAgIHF1ZXJ5Pzoge1xuICAgICAgdXBsb2FkRWRpdHM/OiBVcGxvYWRFZGl0c1xuICAgIH1cbiAgfVxuICBzYXZlZEZpbGVuYW1lOiBzdHJpbmdcbiAgc3RhdGljUGF0aDogc3RyaW5nXG59XG5cbi8qKiBSZXN1bHQgZnJvbSByZXNpemluZyBhbmQgdHJhbnNmb3JtaW5nIHRoZSByZXF1ZXN0ZWQgaW1hZ2Ugc2l6ZXMgKi9cbnR5cGUgSW1hZ2VTaXplc1Jlc3VsdCA9IHtcbiAgc2l6ZURhdGE6IEZpbGVTaXplc1xuICBzaXplc1RvU2F2ZTogRmlsZVRvU2F2ZVtdXG59XG5cbnR5cGUgU2FuaXRpemVkSW1hZ2VEYXRhID0ge1xuICBleHQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSB0aGUgaW1hZ2UgbmFtZSBhbmQgZXh0cmFjdCB0aGUgZXh0ZW5zaW9uIGZyb20gdGhlIHNvdXJjZSBpbWFnZVxuICpcbiAqIEBwYXJhbSBzb3VyY2VJbWFnZSAtIHRoZSBzb3VyY2UgaW1hZ2VcbiAqIEByZXR1cm5zIHRoZSBzYW5pdGl6ZWQgbmFtZSBhbmQgZXh0ZW5zaW9uXG4gKi9cbmNvbnN0IGdldFNhbml0aXplZEltYWdlRGF0YSA9IChzb3VyY2VJbWFnZTogc3RyaW5nKTogU2FuaXRpemVkSW1hZ2VEYXRhID0+IHtcbiAgY29uc3QgZXh0ZW5zaW9uID0gc291cmNlSW1hZ2Uuc3BsaXQoJy4nKS5wb3AoKVxuICBjb25zdCBuYW1lID0gc2FuaXRpemUoc291cmNlSW1hZ2Uuc3Vic3RyaW5nKDAsIHNvdXJjZUltYWdlLmxhc3RJbmRleE9mKCcuJykpIHx8IHNvdXJjZUltYWdlKVxuICByZXR1cm4geyBuYW1lLCBleHQ6IGV4dGVuc2lvbiB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGltYWdlIG5hbWUgYmFzZWQgb24gdGhlIG91dHB1dCBpbWFnZSBuYW1lLCB0aGUgZGltZW5zaW9ucyBhbmRcbiAqIHRoZSBleHRlbnNpb24uXG4gKlxuICogSWdub3JlIHRoZSBmYWN0IHRoYXQgZHVwbGljYXRlIG5hbWVzIGNvdWxkIGhhcHBlbiBpZiB0aGUgdGhlcmUgaXMgb25lXG4gKiBzaXplIHdpdGggYHdpZHRoIEFORCBoZWlnaHRgIGFuZCBvbmUgd2l0aCBvbmx5IGBoZWlnaHQgT1Igd2lkdGhgLiBCZWNhdXNlXG4gKiBzcGFjZSBpcyBleHBlbnNpdmUsIHdlIHdpbGwgcmV1c2UgdGhlIHNhbWUgaW1hZ2UgZm9yIGJvdGggc2l6ZXMuXG4gKlxuICogQHBhcmFtIG91dHB1dEltYWdlTmFtZSAtIHRoZSBzYW5pdGl6ZWQgaW1hZ2UgbmFtZVxuICogQHBhcmFtIGJ1ZmZlckluZm8gLSB0aGUgYnVmZmVyIGluZm9cbiAqIEBwYXJhbSBleHRlbnNpb24gLSB0aGUgZXh0ZW5zaW9uIHRvIHVzZVxuICogQHJldHVybnMgdGhlIG5ldyBpbWFnZSBuYW1lIHRoYXQgaXMgbm90IHRha2VuXG4gKi9cbmNvbnN0IGNyZWF0ZUltYWdlTmFtZSA9IChcbiAgb3V0cHV0SW1hZ2VOYW1lOiBzdHJpbmcsXG4gIHsgaGVpZ2h0LCB3aWR0aCB9OiBPdXRwdXRJbmZvLFxuICBleHRlbnNpb246IHN0cmluZyxcbikgPT4gYCR7b3V0cHV0SW1hZ2VOYW1lfS0ke3dpZHRofXgke2hlaWdodH0uJHtleHRlbnNpb259YFxuXG4vKipcbiAqIENyZWF0ZSB0aGUgcmVzdWx0IG9iamVjdCBmb3IgdGhlIGltYWdlIHJlc2l6ZSBvcGVyYXRpb24gYmFzZWQgb24gdGhlXG4gKiBwcm92aWRlZCBwYXJhbWV0ZXJzLiBJZiB0aGUgbmFtZSBpcyBub3QgcHJvdmlkZWQsIGFuIGVtcHR5IHJlc3VsdCBvYmplY3RcbiAqIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gZmlsZW5hbWUgLSB0aGUgZmlsZW5hbWUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gd2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgaW1hZ2VcbiAqIEBwYXJhbSBmaWxlc2l6ZSAtIHRoZSBmaWxlc2l6ZSBvZiB0aGUgaW1hZ2VcbiAqIEBwYXJhbSBtaW1lVHlwZSAtIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gc2l6ZXNUb1NhdmUgLSB0aGUgc2l6ZXMgdG8gc2F2ZVxuICogQHJldHVybnMgdGhlIHJlc3VsdCBvYmplY3RcbiAqL1xuY29uc3QgY3JlYXRlUmVzdWx0ID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIGZpbGVuYW1lOiBGaWxlU2l6ZVsnZmlsZW5hbWUnXSA9IG51bGwsXG4gIHdpZHRoOiBGaWxlU2l6ZVsnd2lkdGgnXSA9IG51bGwsXG4gIGhlaWdodDogRmlsZVNpemVbJ2hlaWdodCddID0gbnVsbCxcbiAgZmlsZXNpemU6IEZpbGVTaXplWydmaWxlc2l6ZSddID0gbnVsbCxcbiAgbWltZVR5cGU6IEZpbGVTaXplWydtaW1lVHlwZSddID0gbnVsbCxcbiAgc2l6ZXNUb1NhdmU6IEZpbGVUb1NhdmVbXSA9IFtdLFxuKTogSW1hZ2VTaXplc1Jlc3VsdCA9PiAoe1xuICBzaXplRGF0YToge1xuICAgIFtuYW1lXToge1xuICAgICAgZmlsZW5hbWUsXG4gICAgICBmaWxlc2l6ZSxcbiAgICAgIGhlaWdodCxcbiAgICAgIG1pbWVUeXBlLFxuICAgICAgd2lkdGgsXG4gICAgfSxcbiAgfSxcbiAgc2l6ZXNUb1NhdmUsXG59KVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBpbWFnZSBuZWVkcyB0byBiZSByZXNpemVkIGFjY29yZGluZyB0byB0aGUgcmVxdWVzdGVkIGRpbWVuc2lvbnNcbiAqIGFuZCB0aGUgb3JpZ2luYWwgaW1hZ2Ugc2l6ZS4gSWYgdGhlIHJlc2l6ZSBvcHRpb25zIHdpdGhvdXRFbmxhcmdlbWVudCBvciB3aXRob3V0UmVkdWN0aW9uIGFyZSBwcm92aWRlZCxcbiAqIHRoZSBpbWFnZSB3aWxsIGJlIHJlc2l6ZWQgcmVnYXJkbGVzcyBvZiB0aGUgcmVxdWVzdGVkIGRpbWVuc2lvbnMsIGdpdmVuIHRoYXQgdGhlXG4gKiB3aWR0aCBvciBoZWlnaHQgdG8gYmUgcmVzaXplZCBpcyBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0gcmVzaXplQ29uZmlnIC0gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3RlZCBkaW1lbnNpb25zIGFuZCByZXNpemUgb3B0aW9uc1xuICogQHBhcmFtIG9yaWdpbmFsIC0gdGhlIG9yaWdpbmFsIGltYWdlIHNpemVcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGltYWdlIG5lZWRzIHRvIGJlIHJlc2l6ZWQsIGZhbHNlIG90aGVyd2lzZVxuICovXG5jb25zdCBuZWVkc1Jlc2l6ZSA9IChcbiAgeyBoZWlnaHQ6IGRlc2lyZWRIZWlnaHQsIHdpZHRoOiBkZXNpcmVkV2lkdGgsIHdpdGhvdXRFbmxhcmdlbWVudCwgd2l0aG91dFJlZHVjdGlvbiB9OiBJbWFnZVNpemUsXG4gIG9yaWdpbmFsOiBQcm9iZWRJbWFnZVNpemUsXG4pOiBib29sZWFuID0+IHtcbiAgLy8gYWxsb3cgZW5sYXJnZW1lbnQgb3IgcHJldmVudCByZWR1Y3Rpb24gKG91ciBkZWZhdWx0IGlzIHRvIHByZXZlbnRcbiAgLy8gZW5sYXJnZW1lbnQgYW5kIGFsbG93IHJlZHVjdGlvbilcbiAgaWYgKHdpdGhvdXRFbmxhcmdlbWVudCAhPT0gdW5kZWZpbmVkIHx8IHdpdGhvdXRSZWR1Y3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlIC8vIG5lZWRzIHJlc2l6ZVxuICB9XG5cbiAgY29uc3QgaXNXaWR0aE9ySGVpZ2h0Tm90RGVmaW5lZCA9ICFkZXNpcmVkSGVpZ2h0IHx8ICFkZXNpcmVkV2lkdGhcblxuICBpZiAoaXNXaWR0aE9ySGVpZ2h0Tm90RGVmaW5lZCkge1xuICAgIC8vIElmIHdpdGggYW5kIGhlaWdodCBhcmUgbm90IGRlZmluZWQsIGl0IG1lYW5zIHRoZXJlIGlzIGEgZm9ybWF0IGNvbnZlcnNpb25cbiAgICAvLyBhbmQgdGhlIGltYWdlIG5lZWRzIHRvIGJlIFwicmVzaXplZFwiICh0cmFuc2Zvcm1lZCkuXG4gICAgcmV0dXJuIHRydWUgLy8gbmVlZHMgcmVzaXplXG4gIH1cblxuICBjb25zdCBoYXNJbnN1ZmZpY2llbnRXaWR0aCA9IG9yaWdpbmFsLndpZHRoIDwgZGVzaXJlZFdpZHRoXG4gIGNvbnN0IGhhc0luc3VmZmljaWVudEhlaWdodCA9IG9yaWdpbmFsLmhlaWdodCA8IGRlc2lyZWRIZWlnaHRcbiAgaWYgKGhhc0luc3VmZmljaWVudFdpZHRoICYmIGhhc0luc3VmZmljaWVudEhlaWdodCkge1xuICAgIC8vIGRvZXNuJ3QgbmVlZCByZXNpemUgLSBwcmV2ZW50IGVubGFyZ2VtZW50LiBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiBib3RoIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGluc3VmZmljaWVudC5cbiAgICAvLyBpZiBvbmx5IG9uZSBkaW1lbnNpb24gaXMgaW5zdWZmaWNpZW50IGFuZCB0aGUgb3RoZXIgaXMgc3VmZmljaWVudCwgcmVzaXppbmcgbmVlZHMgdG8gaGFwcGVuLCBhcyB0aGUgaW1hZ2VcbiAgICAvLyBzaG91bGQgYmUgcmVzaXplZCB0byB0aGUgc3VmZmljaWVudCBkaW1lbnNpb24uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZSAvLyBuZWVkcyByZXNpemVcbn1cblxuLyoqXG4gKiBGb3IgdGhlIHByb3ZpZGVkIGltYWdlIHNpemVzLCBoYW5kbGUgdGhlIHJlc2l6aW5nIGFuZCB0aGUgdHJhbnNmb3Jtc1xuICogKGZvcm1hdCwgdHJpbSwgZXRjLikgb2YgZWFjaCByZXF1ZXN0ZWQgaW1hZ2Ugc2l6ZSBhbmQgcmV0dXJuIHRoZSByZXN1bHQgb2JqZWN0LlxuICogVGhpcyBvbmx5IGhhbmRsZXMgdGhlIGltYWdlIHNpemVzLiBUaGUgdHJhbnNmb3JtcyBvZiB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAqIGFyZSBoYW5kbGVkIGluIHtAbGluayAuL2dlbmVyYXRlRmlsZURhdGEudHN9LlxuICpcbiAqIFRoZSBpbWFnZSB3aWxsIGJlIHJlc2l6ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZFxuICogcmVzaXplIGNvbmZpZy4gSWYgbm8gaW1hZ2Ugc2l6ZXMgYXJlIHJlcXVlc3RlZCwgdGhlIHJlc29sdmVkIGRhdGEgd2lsbCBiZSBlbXB0eS5cbiAqIEZvciBldmVyeSBpbWFnZSB0aGF0IGRvcyBub3QgbmVlZCB0byBiZSByZXNpemVkLCBhbiByZXN1bHQgb2JqZWN0IHdpdGggYG51bGxgXG4gKiBwYXJhbWV0ZXJzIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHJlc2l6ZUNvbmZpZyAtIHRoZSByZXNpemUgY29uZmlnXG4gKiBAcmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSByZXNpemUgb3BlcmF0aW9uKHMpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHJlc2l6ZUFuZFRyYW5zZm9ybUltYWdlU2l6ZXMoe1xuICBjb25maWcsXG4gIGRpbWVuc2lvbnMsXG4gIGZpbGUsXG4gIG1pbWVUeXBlLFxuICByZXEsXG4gIHNhdmVkRmlsZW5hbWUsXG4gIHN0YXRpY1BhdGgsXG59OiBSZXNpemVBcmdzKTogUHJvbWlzZTxJbWFnZVNpemVzUmVzdWx0PiB7XG4gIGNvbnN0IHsgaW1hZ2VTaXplcyB9ID0gY29uZmlnLnVwbG9hZFxuICAvLyBOb3RpbmcgdG8gcmVzaXplIGhlcmUgc28gcmV0dXJuIGFzIGVhcmx5IGFzIHBvc3NpYmxlXG4gIGlmICghaW1hZ2VTaXplcykgcmV0dXJuIHsgc2l6ZURhdGE6IHt9LCBzaXplc1RvU2F2ZTogW10gfVxuXG4gIGNvbnN0IHNoYXJwQmFzZSA9IHNoYXJwKGZpbGUudGVtcEZpbGVQYXRoIHx8IGZpbGUuZGF0YSkucm90YXRlKCkgLy8gcGFzcyByb3RhdGUoKSB0byBhdXRvLXJvdGF0ZSBiYXNlZCBvbiBFWElGIGRhdGEuIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXlsb2FkY21zL3BheWxvYWQvcHVsbC8zMDgxXG5cbiAgY29uc3QgcmVzdWx0czogSW1hZ2VTaXplc1Jlc3VsdFtdID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgaW1hZ2VTaXplcy5tYXAoYXN5bmMgKGltYWdlUmVzaXplQ29uZmlnKTogUHJvbWlzZTxJbWFnZVNpemVzUmVzdWx0PiA9PiB7XG4gICAgICAvLyBUaGlzIGNoZWNrcyBpZiBhIHJlc2l6ZSBzaG91bGQgaGFwcGVuLiBJZiBub3QsIHRoZSByZXNpemVkIGltYWdlIHdpbGwgYmVcbiAgICAgIC8vIHNraXBwZWQgQ09NUExFVEVMWSBhbmQgdGh1cyB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIGltYWdlcy5cbiAgICAgIC8vIEFsbCBmdXJ0aGVyIGZvcm1hdC90cmltIG9wdGlvbnMgd2lsbCB0aHVzIGJlIHNraXBwZWQgYXMgd2VsbC5cbiAgICAgIGlmICghbmVlZHNSZXNpemUoaW1hZ2VSZXNpemVDb25maWcsIGRpbWVuc2lvbnMpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZXN1bHQoaW1hZ2VSZXNpemVDb25maWcubmFtZSlcbiAgICAgIH1cbiAgICAgIGxldCByZXNpemVkID0gc2hhcnBCYXNlLmNsb25lKClcblxuICAgICAgY29uc3QgaGFzRWRpdHMgPSByZXEucXVlcnk/LnVwbG9hZEVkaXRzXG5cbiAgICAgIGlmIChoYXNFZGl0cyAmJiBpbWFnZVJlc2l6ZUNvbmZpZy53aWR0aCAmJiBpbWFnZVJlc2l6ZUNvbmZpZy5oZWlnaHQpIHtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBpbWFnZVJlc2l6ZUNvbmZpZ1xuXG4gICAgICAgIGNvbnN0IHRhcmdldEFzcGVjdFJhdGlvID0gd2lkdGggLyBoZWlnaHRcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxBc3BlY3RSYXRpbyA9IGRpbWVuc2lvbnMud2lkdGggLyBkaW1lbnNpb25zLmhlaWdodFxuXG4gICAgICAgIGlmIChvcmlnaW5hbEFzcGVjdFJhdGlvID09PSB0YXJnZXRBc3BlY3RSYXRpbykge1xuICAgICAgICAgIHJlc2l6ZWQgPSByZXNpemVkLnJlc2l6ZShpbWFnZVJlc2l6ZUNvbmZpZylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBmb2NhbFBvaW50ID0ge1xuICAgICAgICAgICAgeDogMC41LFxuICAgICAgICAgICAgeTogMC41LFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXEucXVlcnkudXBsb2FkRWRpdHM/LmZvY2FsUG9pbnQpIHtcbiAgICAgICAgICAgIGlmIChpc051bWJlcihyZXEucXVlcnkudXBsb2FkRWRpdHMuZm9jYWxQb2ludD8ueCkpIHtcbiAgICAgICAgICAgICAgZm9jYWxQb2ludC54ID0gcmVxLnF1ZXJ5LnVwbG9hZEVkaXRzLmZvY2FsUG9pbnQueFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHJlcS5xdWVyeS51cGxvYWRFZGl0cy5mb2NhbFBvaW50Py55KSkge1xuICAgICAgICAgICAgICBmb2NhbFBvaW50LnkgPSByZXEucXVlcnkudXBsb2FkRWRpdHMuZm9jYWxQb2ludC55XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcHJpb3JpdGl6ZUhlaWdodCA9IG9yaWdpbmFsQXNwZWN0UmF0aW8gPiB0YXJnZXRBc3BlY3RSYXRpb1xuXG4gICAgICAgICAgY29uc3QgeyBpbmZvIH0gPSBhd2FpdCByZXNpemVkXG4gICAgICAgICAgICAucmVzaXplKHtcbiAgICAgICAgICAgICAgaGVpZ2h0OiBwcmlvcml0aXplSGVpZ2h0ID8gaGVpZ2h0IDogbnVsbCxcbiAgICAgICAgICAgICAgd2lkdGg6IHByaW9yaXRpemVIZWlnaHQgPyBudWxsIDogd2lkdGgsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRvQnVmZmVyKHsgcmVzb2x2ZVdpdGhPYmplY3Q6IHRydWUgfSlcblxuICAgICAgICAgIGNvbnN0IG1heE9mZnNldFggPSBNYXRoLm1heChpbmZvLndpZHRoIC0gd2lkdGgsIDApXG4gICAgICAgICAgY29uc3QgbWF4T2Zmc2V0WSA9IE1hdGgubWF4KGluZm8uaGVpZ2h0IC0gaGVpZ2h0LCAwKVxuXG4gICAgICAgICAgY29uc3QgZm9jYWxQb2ludFggPSBNYXRoLmZsb29yKChpbmZvLndpZHRoIC8gMTAwKSAqIGZvY2FsUG9pbnQueClcbiAgICAgICAgICBjb25zdCBmb2NhbFBvaW50WSA9IE1hdGguZmxvb3IoKGluZm8uaGVpZ2h0IC8gMTAwKSAqIGZvY2FsUG9pbnQueSlcblxuICAgICAgICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLm1pbihNYXRoLm1heChmb2NhbFBvaW50WCAtIHdpZHRoIC8gMiwgMCksIG1heE9mZnNldFgpXG4gICAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGgubWluKE1hdGgubWF4KGZvY2FsUG9pbnRZIC0gaGVpZ2h0IC8gMiwgMCksIG1heE9mZnNldFkpXG5cbiAgICAgICAgICByZXNpemVkID0gcmVzaXplZC5leHRyYWN0KHtcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIGxlZnQ6IG9mZnNldFgsXG4gICAgICAgICAgICB0b3A6IG9mZnNldFksXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNpemVkID0gcmVzaXplZC5yZXNpemUoaW1hZ2VSZXNpemVDb25maWcpXG4gICAgICB9XG5cbiAgICAgIGlmIChpbWFnZVJlc2l6ZUNvbmZpZy5mb3JtYXRPcHRpb25zKSB7XG4gICAgICAgIHJlc2l6ZWQgPSByZXNpemVkLnRvRm9ybWF0KFxuICAgICAgICAgIGltYWdlUmVzaXplQ29uZmlnLmZvcm1hdE9wdGlvbnMuZm9ybWF0LFxuICAgICAgICAgIGltYWdlUmVzaXplQ29uZmlnLmZvcm1hdE9wdGlvbnMub3B0aW9ucyxcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoaW1hZ2VSZXNpemVDb25maWcudHJpbU9wdGlvbnMpIHtcbiAgICAgICAgcmVzaXplZCA9IHJlc2l6ZWQudHJpbShpbWFnZVJlc2l6ZUNvbmZpZy50cmltT3B0aW9ucylcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBkYXRhOiBidWZmZXJEYXRhLCBpbmZvOiBidWZmZXJJbmZvIH0gPSBhd2FpdCByZXNpemVkLnRvQnVmZmVyKHtcbiAgICAgICAgcmVzb2x2ZVdpdGhPYmplY3Q6IHRydWUsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBzYW5pdGl6ZWRJbWFnZSA9IGdldFNhbml0aXplZEltYWdlRGF0YShzYXZlZEZpbGVuYW1lKVxuXG4gICAgICBpZiAocmVxLnBheWxvYWRVcGxvYWRTaXplcykge1xuICAgICAgICByZXEucGF5bG9hZFVwbG9hZFNpemVzW2ltYWdlUmVzaXplQ29uZmlnLm5hbWVdID0gYnVmZmVyRGF0YVxuICAgICAgfVxuXG4gICAgICBjb25zdCBtaW1lSW5mbyA9IGF3YWl0IGZyb21CdWZmZXIoYnVmZmVyRGF0YSlcblxuICAgICAgY29uc3QgaW1hZ2VOYW1lV2l0aERpbWVuc2lvbnMgPSBjcmVhdGVJbWFnZU5hbWUoXG4gICAgICAgIHNhbml0aXplZEltYWdlLm5hbWUsXG4gICAgICAgIGJ1ZmZlckluZm8sXG4gICAgICAgIG1pbWVJbmZvPy5leHQgfHwgc2FuaXRpemVkSW1hZ2UuZXh0LFxuICAgICAgKVxuXG4gICAgICBjb25zdCBpbWFnZVBhdGggPSBgJHtzdGF0aWNQYXRofS8ke2ltYWdlTmFtZVdpdGhEaW1lbnNpb25zfWBcblxuICAgICAgaWYgKGF3YWl0IGZpbGVFeGlzdHMoaW1hZ2VQYXRoKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZzLnVubGlua1N5bmMoaW1hZ2VQYXRoKVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvLyBJZ25vcmUgdW5saW5rIGVycm9yc1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgaGVpZ2h0LCBzaXplLCB3aWR0aCB9ID0gYnVmZmVySW5mb1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlc3VsdChcbiAgICAgICAgaW1hZ2VSZXNpemVDb25maWcubmFtZSxcbiAgICAgICAgaW1hZ2VOYW1lV2l0aERpbWVuc2lvbnMsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHNpemUsXG4gICAgICAgIG1pbWVJbmZvPy5taW1lIHx8IG1pbWVUeXBlLFxuICAgICAgICBbeyBidWZmZXI6IGJ1ZmZlckRhdGEsIHBhdGg6IGltYWdlUGF0aCB9XSxcbiAgICAgIClcbiAgICB9KSxcbiAgKVxuXG4gIHJldHVybiByZXN1bHRzLnJlZHVjZShcbiAgICAoYWNjLCByZXN1bHQpID0+IHtcbiAgICAgIE9iamVjdC5hc3NpZ24oYWNjLnNpemVEYXRhLCByZXN1bHQuc2l6ZURhdGEpXG4gICAgICBhY2Muc2l6ZXNUb1NhdmUucHVzaCguLi5yZXN1bHQuc2l6ZXNUb1NhdmUpXG4gICAgICByZXR1cm4gYWNjXG4gICAgfSxcbiAgICB7IHNpemVEYXRhOiB7fSwgc2l6ZXNUb1NhdmU6IFtdIH0sXG4gIClcbn1cbiJdLCJuYW1lcyI6WyJyZXNpemVBbmRUcmFuc2Zvcm1JbWFnZVNpemVzIiwiZ2V0U2FuaXRpemVkSW1hZ2VEYXRhIiwic291cmNlSW1hZ2UiLCJleHRlbnNpb24iLCJzcGxpdCIsInBvcCIsIm5hbWUiLCJzYW5pdGl6ZSIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwiZXh0IiwiY3JlYXRlSW1hZ2VOYW1lIiwib3V0cHV0SW1hZ2VOYW1lIiwiaGVpZ2h0Iiwid2lkdGgiLCJjcmVhdGVSZXN1bHQiLCJmaWxlbmFtZSIsImZpbGVzaXplIiwibWltZVR5cGUiLCJzaXplc1RvU2F2ZSIsInNpemVEYXRhIiwibmVlZHNSZXNpemUiLCJkZXNpcmVkSGVpZ2h0IiwiZGVzaXJlZFdpZHRoIiwid2l0aG91dEVubGFyZ2VtZW50Iiwid2l0aG91dFJlZHVjdGlvbiIsIm9yaWdpbmFsIiwidW5kZWZpbmVkIiwiaXNXaWR0aE9ySGVpZ2h0Tm90RGVmaW5lZCIsImhhc0luc3VmZmljaWVudFdpZHRoIiwiaGFzSW5zdWZmaWNpZW50SGVpZ2h0IiwiY29uZmlnIiwiZGltZW5zaW9ucyIsImZpbGUiLCJyZXEiLCJzYXZlZEZpbGVuYW1lIiwic3RhdGljUGF0aCIsImltYWdlU2l6ZXMiLCJ1cGxvYWQiLCJzaGFycEJhc2UiLCJzaGFycCIsInRlbXBGaWxlUGF0aCIsImRhdGEiLCJyb3RhdGUiLCJyZXN1bHRzIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImltYWdlUmVzaXplQ29uZmlnIiwicmVzaXplZCIsImNsb25lIiwiaGFzRWRpdHMiLCJxdWVyeSIsInVwbG9hZEVkaXRzIiwidGFyZ2V0QXNwZWN0UmF0aW8iLCJvcmlnaW5hbEFzcGVjdFJhdGlvIiwicmVzaXplIiwiZm9jYWxQb2ludCIsIngiLCJ5IiwiaXNOdW1iZXIiLCJwcmlvcml0aXplSGVpZ2h0IiwiaW5mbyIsInRvQnVmZmVyIiwicmVzb2x2ZVdpdGhPYmplY3QiLCJtYXhPZmZzZXRYIiwiTWF0aCIsIm1heCIsIm1heE9mZnNldFkiLCJmb2NhbFBvaW50WCIsImZsb29yIiwiZm9jYWxQb2ludFkiLCJvZmZzZXRYIiwibWluIiwib2Zmc2V0WSIsImV4dHJhY3QiLCJsZWZ0IiwidG9wIiwiZm9ybWF0T3B0aW9ucyIsInRvRm9ybWF0IiwiZm9ybWF0Iiwib3B0aW9ucyIsInRyaW1PcHRpb25zIiwidHJpbSIsImJ1ZmZlckRhdGEiLCJidWZmZXJJbmZvIiwic2FuaXRpemVkSW1hZ2UiLCJwYXlsb2FkVXBsb2FkU2l6ZXMiLCJtaW1lSW5mbyIsImZyb21CdWZmZXIiLCJpbWFnZU5hbWVXaXRoRGltZW5zaW9ucyIsImltYWdlUGF0aCIsImZpbGVFeGlzdHMiLCJmcyIsInVubGlua1N5bmMiLCJzaXplIiwibWltZSIsImJ1ZmZlciIsInBhdGgiLCJyZWR1Y2UiLCJhY2MiLCJyZXN1bHQiLCJPYmplY3QiLCJhc3NpZ24iLCJwdXNoIl0sIm1hcHBpbmdzIjoiOzs7OytCQW1KQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ0Q7OztlQUE4QkE7OzswQkE5Skg7MkRBQ1o7eUVBQ007OERBQ0g7MEJBT087bUVBQ0Y7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