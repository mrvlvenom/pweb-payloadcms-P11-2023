"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getDataLoader", {
    enumerable: true,
    get: function() {
        return getDataLoader;
    }
});
const _dataloader = /*#__PURE__*/ _interop_require_default(require("dataloader"));
const _types = require("../fields/config/types");
const _getIDType = require("../utilities/getIDType");
const _isValidID = require("../utilities/isValidID");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Payload uses `dataloader` to solve the classic GraphQL N+1 problem.
// We keep a list of all documents requested to be populated for any given request
// and then batch together documents within the same collection,
// making only 1 find per each collection, rather than `findByID` per each requested doc.
// This dramatically improves performance for REST and Local API `depth` populations,
// and also ensures complex GraphQL queries perform lightning-fast.
const batchAndLoadDocs = (req)=>async (keys)=>{
        const { payload } = req;
        // Create docs array of same length as keys, using null as value
        // We will replace nulls with injected docs as they are retrieved
        const docs = keys.map(()=>null);
        // Batch IDs by their `find` args
        // so we can make one find query per combination of collection, depth, locale, and fallbackLocale.
        // Resulting shape will be as follows:
        // {
        //   // key is stringified set of find args
        //   '[null,"pages",2,0,"es","en",false,false]': [
        //     // value is array of IDs to find with these args
        //     'q34tl23462346234524',
        //     '435523540194324280',
        //     '2346245j35l3j5234532li',
        //   ],
        //   // etc
        // };
        const batchByFindArgs = keys.reduce((batches, key)=>{
            const [transactionID, collection, id, depth, currentDepth, locale, fallbackLocale, overrideAccess, showHiddenFields] = JSON.parse(key);
            const batchKeyArray = [
                transactionID,
                collection,
                depth,
                currentDepth,
                locale,
                fallbackLocale,
                overrideAccess,
                showHiddenFields
            ];
            const batchKey = JSON.stringify(batchKeyArray);
            const idField = payload.collections?.[collection].config.fields.find((field)=>(0, _types.fieldAffectsData)(field) && field.name === 'id');
            let sanitizedID = id;
            if (idField?.type === 'number') sanitizedID = parseFloat(id);
            if ((0, _isValidID.isValidID)(sanitizedID, (0, _getIDType.getIDType)(idField, payload?.db?.defaultIDType))) {
                return {
                    ...batches,
                    [batchKey]: [
                        ...batches[batchKey] || [],
                        sanitizedID
                    ]
                };
            }
            return batches;
        }, {});
        // Run find requests in parallel
        const results = Object.entries(batchByFindArgs).map(async ([batchKey, ids])=>{
            const [transactionID, collection, depth, currentDepth, locale, fallbackLocale, overrideAccess, showHiddenFields] = JSON.parse(batchKey);
            req.transactionID = transactionID;
            const result = await payload.find({
                collection,
                currentDepth,
                depth,
                disableErrors: true,
                fallbackLocale,
                locale,
                overrideAccess: Boolean(overrideAccess),
                pagination: false,
                req,
                showHiddenFields: Boolean(showHiddenFields),
                where: {
                    id: {
                        in: ids
                    }
                }
            });
            // For each returned doc, find index in original keys
            // Inject doc within docs array if index exists
            result.docs.forEach((doc)=>{
                const docKey = JSON.stringify([
                    req.transactionID,
                    collection,
                    doc.id,
                    depth,
                    currentDepth,
                    locale,
                    fallbackLocale,
                    overrideAccess,
                    showHiddenFields
                ]);
                const docsIndex = keys.findIndex((key)=>key === docKey);
                if (docsIndex > -1) {
                    docs[docsIndex] = doc;
                }
            });
        });
        await Promise.all(results);
        // Return docs array,
        // which has now been injected with all fetched docs
        // and should match the length of the incoming keys arg
        return docs;
    };
const getDataLoader = (req)=>new _dataloader.default(batchAndLoadDocs(req));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb2xsZWN0aW9ucy9kYXRhbG9hZGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQmF0Y2hMb2FkRm4gfSBmcm9tICdkYXRhbG9hZGVyJ1xuXG5pbXBvcnQgRGF0YUxvYWRlciBmcm9tICdkYXRhbG9hZGVyJ1xuXG5pbXBvcnQgdHlwZSB7IFBheWxvYWRSZXF1ZXN0IH0gZnJvbSAnLi4vZXhwcmVzcy90eXBlcydcbmltcG9ydCB0eXBlIHsgVHlwZVdpdGhJRCB9IGZyb20gJy4vY29uZmlnL3R5cGVzJ1xuXG5pbXBvcnQgeyBmaWVsZEFmZmVjdHNEYXRhIH0gZnJvbSAnLi4vZmllbGRzL2NvbmZpZy90eXBlcydcbmltcG9ydCB7IGdldElEVHlwZSB9IGZyb20gJy4uL3V0aWxpdGllcy9nZXRJRFR5cGUnXG5pbXBvcnQgeyBpc1ZhbGlkSUQgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNWYWxpZElEJ1xuXG4vLyBQYXlsb2FkIHVzZXMgYGRhdGFsb2FkZXJgIHRvIHNvbHZlIHRoZSBjbGFzc2ljIEdyYXBoUUwgTisxIHByb2JsZW0uXG5cbi8vIFdlIGtlZXAgYSBsaXN0IG9mIGFsbCBkb2N1bWVudHMgcmVxdWVzdGVkIHRvIGJlIHBvcHVsYXRlZCBmb3IgYW55IGdpdmVuIHJlcXVlc3Rcbi8vIGFuZCB0aGVuIGJhdGNoIHRvZ2V0aGVyIGRvY3VtZW50cyB3aXRoaW4gdGhlIHNhbWUgY29sbGVjdGlvbixcbi8vIG1ha2luZyBvbmx5IDEgZmluZCBwZXIgZWFjaCBjb2xsZWN0aW9uLCByYXRoZXIgdGhhbiBgZmluZEJ5SURgIHBlciBlYWNoIHJlcXVlc3RlZCBkb2MuXG5cbi8vIFRoaXMgZHJhbWF0aWNhbGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlIGZvciBSRVNUIGFuZCBMb2NhbCBBUEkgYGRlcHRoYCBwb3B1bGF0aW9ucyxcbi8vIGFuZCBhbHNvIGVuc3VyZXMgY29tcGxleCBHcmFwaFFMIHF1ZXJpZXMgcGVyZm9ybSBsaWdodG5pbmctZmFzdC5cblxuY29uc3QgYmF0Y2hBbmRMb2FkRG9jcyA9XG4gIChyZXE6IFBheWxvYWRSZXF1ZXN0KTogQmF0Y2hMb2FkRm48c3RyaW5nLCBUeXBlV2l0aElEPiA9PlxuICBhc3luYyAoa2V5czogc3RyaW5nW10pOiBQcm9taXNlPFR5cGVXaXRoSURbXT4gPT4ge1xuICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gcmVxXG5cbiAgICAvLyBDcmVhdGUgZG9jcyBhcnJheSBvZiBzYW1lIGxlbmd0aCBhcyBrZXlzLCB1c2luZyBudWxsIGFzIHZhbHVlXG4gICAgLy8gV2Ugd2lsbCByZXBsYWNlIG51bGxzIHdpdGggaW5qZWN0ZWQgZG9jcyBhcyB0aGV5IGFyZSByZXRyaWV2ZWRcbiAgICBjb25zdCBkb2NzOiAoVHlwZVdpdGhJRCB8IG51bGwpW10gPSBrZXlzLm1hcCgoKSA9PiBudWxsKVxuXG4gICAgLy8gQmF0Y2ggSURzIGJ5IHRoZWlyIGBmaW5kYCBhcmdzXG4gICAgLy8gc28gd2UgY2FuIG1ha2Ugb25lIGZpbmQgcXVlcnkgcGVyIGNvbWJpbmF0aW9uIG9mIGNvbGxlY3Rpb24sIGRlcHRoLCBsb2NhbGUsIGFuZCBmYWxsYmFja0xvY2FsZS5cblxuICAgIC8vIFJlc3VsdGluZyBzaGFwZSB3aWxsIGJlIGFzIGZvbGxvd3M6XG5cbiAgICAvLyB7XG4gICAgLy8gICAvLyBrZXkgaXMgc3RyaW5naWZpZWQgc2V0IG9mIGZpbmQgYXJnc1xuICAgIC8vICAgJ1tudWxsLFwicGFnZXNcIiwyLDAsXCJlc1wiLFwiZW5cIixmYWxzZSxmYWxzZV0nOiBbXG4gICAgLy8gICAgIC8vIHZhbHVlIGlzIGFycmF5IG9mIElEcyB0byBmaW5kIHdpdGggdGhlc2UgYXJnc1xuICAgIC8vICAgICAncTM0dGwyMzQ2MjM0NjIzNDUyNCcsXG4gICAgLy8gICAgICc0MzU1MjM1NDAxOTQzMjQyODAnLFxuICAgIC8vICAgICAnMjM0NjI0NWozNWwzajUyMzQ1MzJsaScsXG4gICAgLy8gICBdLFxuICAgIC8vICAgLy8gZXRjXG4gICAgLy8gfTtcblxuICAgIGNvbnN0IGJhdGNoQnlGaW5kQXJncyA9IGtleXMucmVkdWNlKChiYXRjaGVzLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IFtcbiAgICAgICAgdHJhbnNhY3Rpb25JRCxcbiAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgaWQsXG4gICAgICAgIGRlcHRoLFxuICAgICAgICBjdXJyZW50RGVwdGgsXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgZmFsbGJhY2tMb2NhbGUsXG4gICAgICAgIG92ZXJyaWRlQWNjZXNzLFxuICAgICAgICBzaG93SGlkZGVuRmllbGRzLFxuICAgICAgXSA9IEpTT04ucGFyc2Uoa2V5KVxuXG4gICAgICBjb25zdCBiYXRjaEtleUFycmF5ID0gW1xuICAgICAgICB0cmFuc2FjdGlvbklELFxuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBkZXB0aCxcbiAgICAgICAgY3VycmVudERlcHRoLFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIGZhbGxiYWNrTG9jYWxlLFxuICAgICAgICBvdmVycmlkZUFjY2VzcyxcbiAgICAgICAgc2hvd0hpZGRlbkZpZWxkcyxcbiAgICAgIF1cblxuICAgICAgY29uc3QgYmF0Y2hLZXkgPSBKU09OLnN0cmluZ2lmeShiYXRjaEtleUFycmF5KVxuXG4gICAgICBjb25zdCBpZEZpZWxkID0gcGF5bG9hZC5jb2xsZWN0aW9ucz8uW2NvbGxlY3Rpb25dLmNvbmZpZy5maWVsZHMuZmluZChcbiAgICAgICAgKGZpZWxkKSA9PiBmaWVsZEFmZmVjdHNEYXRhKGZpZWxkKSAmJiBmaWVsZC5uYW1lID09PSAnaWQnLFxuICAgICAgKVxuXG4gICAgICBsZXQgc2FuaXRpemVkSUQ6IG51bWJlciB8IHN0cmluZyA9IGlkXG5cbiAgICAgIGlmIChpZEZpZWxkPy50eXBlID09PSAnbnVtYmVyJykgc2FuaXRpemVkSUQgPSBwYXJzZUZsb2F0KGlkKVxuXG4gICAgICBpZiAoaXNWYWxpZElEKHNhbml0aXplZElELCBnZXRJRFR5cGUoaWRGaWVsZCwgcGF5bG9hZD8uZGI/LmRlZmF1bHRJRFR5cGUpKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmJhdGNoZXMsXG4gICAgICAgICAgW2JhdGNoS2V5XTogWy4uLihiYXRjaGVzW2JhdGNoS2V5XSB8fCBbXSksIHNhbml0aXplZElEXSxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJhdGNoZXNcbiAgICB9LCB7fSlcblxuICAgIC8vIFJ1biBmaW5kIHJlcXVlc3RzIGluIHBhcmFsbGVsXG5cbiAgICBjb25zdCByZXN1bHRzID0gT2JqZWN0LmVudHJpZXMoYmF0Y2hCeUZpbmRBcmdzKS5tYXAoYXN5bmMgKFtiYXRjaEtleSwgaWRzXSkgPT4ge1xuICAgICAgY29uc3QgW1xuICAgICAgICB0cmFuc2FjdGlvbklELFxuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBkZXB0aCxcbiAgICAgICAgY3VycmVudERlcHRoLFxuICAgICAgICBsb2NhbGUsXG4gICAgICAgIGZhbGxiYWNrTG9jYWxlLFxuICAgICAgICBvdmVycmlkZUFjY2VzcyxcbiAgICAgICAgc2hvd0hpZGRlbkZpZWxkcyxcbiAgICAgIF0gPSBKU09OLnBhcnNlKGJhdGNoS2V5KVxuXG4gICAgICByZXEudHJhbnNhY3Rpb25JRCA9IHRyYW5zYWN0aW9uSURcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcGF5bG9hZC5maW5kKHtcbiAgICAgICAgY29sbGVjdGlvbixcbiAgICAgICAgY3VycmVudERlcHRoLFxuICAgICAgICBkZXB0aCxcbiAgICAgICAgZGlzYWJsZUVycm9yczogdHJ1ZSxcbiAgICAgICAgZmFsbGJhY2tMb2NhbGUsXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgb3ZlcnJpZGVBY2Nlc3M6IEJvb2xlYW4ob3ZlcnJpZGVBY2Nlc3MpLFxuICAgICAgICBwYWdpbmF0aW9uOiBmYWxzZSxcbiAgICAgICAgcmVxLFxuICAgICAgICBzaG93SGlkZGVuRmllbGRzOiBCb29sZWFuKHNob3dIaWRkZW5GaWVsZHMpLFxuICAgICAgICB3aGVyZToge1xuICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICBpbjogaWRzLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICAvLyBGb3IgZWFjaCByZXR1cm5lZCBkb2MsIGZpbmQgaW5kZXggaW4gb3JpZ2luYWwga2V5c1xuICAgICAgLy8gSW5qZWN0IGRvYyB3aXRoaW4gZG9jcyBhcnJheSBpZiBpbmRleCBleGlzdHNcblxuICAgICAgcmVzdWx0LmRvY3MuZm9yRWFjaCgoZG9jKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvY0tleSA9IEpTT04uc3RyaW5naWZ5KFtcbiAgICAgICAgICByZXEudHJhbnNhY3Rpb25JRCxcbiAgICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICAgIGRvYy5pZCxcbiAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICBjdXJyZW50RGVwdGgsXG4gICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgIGZhbGxiYWNrTG9jYWxlLFxuICAgICAgICAgIG92ZXJyaWRlQWNjZXNzLFxuICAgICAgICAgIHNob3dIaWRkZW5GaWVsZHMsXG4gICAgICAgIF0pXG4gICAgICAgIGNvbnN0IGRvY3NJbmRleCA9IGtleXMuZmluZEluZGV4KChrZXkpID0+IGtleSA9PT0gZG9jS2V5KVxuXG4gICAgICAgIGlmIChkb2NzSW5kZXggPiAtMSkge1xuICAgICAgICAgIGRvY3NbZG9jc0luZGV4XSA9IGRvY1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChyZXN1bHRzKVxuXG4gICAgLy8gUmV0dXJuIGRvY3MgYXJyYXksXG4gICAgLy8gd2hpY2ggaGFzIG5vdyBiZWVuIGluamVjdGVkIHdpdGggYWxsIGZldGNoZWQgZG9jc1xuICAgIC8vIGFuZCBzaG91bGQgbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgaW5jb21pbmcga2V5cyBhcmdcbiAgICByZXR1cm4gZG9jc1xuICB9XG5cbmV4cG9ydCBjb25zdCBnZXREYXRhTG9hZGVyID0gKHJlcTogUGF5bG9hZFJlcXVlc3QpID0+IG5ldyBEYXRhTG9hZGVyKGJhdGNoQW5kTG9hZERvY3MocmVxKSlcbiJdLCJuYW1lcyI6WyJnZXREYXRhTG9hZGVyIiwiYmF0Y2hBbmRMb2FkRG9jcyIsInJlcSIsImtleXMiLCJwYXlsb2FkIiwiZG9jcyIsIm1hcCIsImJhdGNoQnlGaW5kQXJncyIsInJlZHVjZSIsImJhdGNoZXMiLCJrZXkiLCJ0cmFuc2FjdGlvbklEIiwiY29sbGVjdGlvbiIsImlkIiwiZGVwdGgiLCJjdXJyZW50RGVwdGgiLCJsb2NhbGUiLCJmYWxsYmFja0xvY2FsZSIsIm92ZXJyaWRlQWNjZXNzIiwic2hvd0hpZGRlbkZpZWxkcyIsIkpTT04iLCJwYXJzZSIsImJhdGNoS2V5QXJyYXkiLCJiYXRjaEtleSIsInN0cmluZ2lmeSIsImlkRmllbGQiLCJjb2xsZWN0aW9ucyIsImNvbmZpZyIsImZpZWxkcyIsImZpbmQiLCJmaWVsZCIsImZpZWxkQWZmZWN0c0RhdGEiLCJuYW1lIiwic2FuaXRpemVkSUQiLCJ0eXBlIiwicGFyc2VGbG9hdCIsImlzVmFsaWRJRCIsImdldElEVHlwZSIsImRiIiwiZGVmYXVsdElEVHlwZSIsInJlc3VsdHMiLCJPYmplY3QiLCJlbnRyaWVzIiwiaWRzIiwicmVzdWx0IiwiZGlzYWJsZUVycm9ycyIsIkJvb2xlYW4iLCJwYWdpbmF0aW9uIiwid2hlcmUiLCJpbiIsImZvckVhY2giLCJkb2MiLCJkb2NLZXkiLCJkb2NzSW5kZXgiLCJmaW5kSW5kZXgiLCJQcm9taXNlIiwiYWxsIiwiRGF0YUxvYWRlciJdLCJtYXBwaW5ncyI6Ijs7OzsrQkF5SmFBOzs7ZUFBQUE7OzttRUF2SlU7dUJBS1U7MkJBQ1A7MkJBQ0E7Ozs7OztBQUUxQixzRUFBc0U7QUFFdEUsa0ZBQWtGO0FBQ2xGLGdFQUFnRTtBQUNoRSx5RkFBeUY7QUFFekYscUZBQXFGO0FBQ3JGLG1FQUFtRTtBQUVuRSxNQUFN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